<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>V4 Formal Graph Rules & Valid Pattern Enumeration — GamED.AI</title>
<script src="https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.min.js"></script>
<style>
  :root {
    --bg: #0d1117;
    --surface: #161b22;
    --border: #30363d;
    --text: #e6edf3;
    --text-muted: #8b949e;
    --accent: #58a6ff;
    --green: #3fb950;
    --orange: #d29922;
    --red: #f85149;
    --purple: #bc8cff;
    --pink: #f778ba;
    --cyan: #39d2c0;
  }
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
    background: var(--bg);
    color: var(--text);
    line-height: 1.6;
  }
  .header {
    background: linear-gradient(135deg, #1a1f35 0%, #0d1117 100%);
    border-bottom: 1px solid var(--border);
    padding: 24px 32px;
  }
  .header h1 { font-size: 24px; font-weight: 600; }
  .header p { color: var(--text-muted); margin-top: 4px; font-size: 14px; }
  .tabs {
    display: flex;
    flex-wrap: wrap;
    gap: 2px;
    background: var(--surface);
    border-bottom: 1px solid var(--border);
    padding: 0 24px;
    overflow-x: auto;
  }
  .tab {
    padding: 10px 16px;
    cursor: pointer;
    font-size: 13px;
    color: var(--text-muted);
    border-bottom: 2px solid transparent;
    white-space: nowrap;
    transition: all 0.2s;
  }
  .tab:hover { color: var(--text); background: rgba(88,166,255,0.05); }
  .tab.active { color: var(--accent); border-bottom-color: var(--accent); }
  .content { display: none; padding: 32px; max-width: 1400px; margin: 0 auto; }
  .content.active { display: block; }
  .card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 24px;
    margin-bottom: 24px;
  }
  .card h2 { font-size: 18px; margin-bottom: 16px; color: var(--accent); }
  .card h3 { font-size: 15px; margin: 16px 0 8px; color: var(--green); }
  .card h4 { font-size: 14px; margin: 12px 0 6px; color: var(--orange); }
  table { width: 100%; border-collapse: collapse; font-size: 13px; margin: 12px 0; }
  th, td { padding: 8px 12px; border: 1px solid var(--border); text-align: left; }
  th { background: rgba(88,166,255,0.1); font-weight: 600; }
  tr:nth-child(even) { background: rgba(255,255,255,0.02); }
  code {
    background: rgba(110,118,129,0.2);
    padding: 2px 6px;
    border-radius: 4px;
    font-size: 12px;
    font-family: 'SF Mono', 'Fira Code', monospace;
  }
  pre {
    background: #0d1117;
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 16px;
    overflow-x: auto;
    font-size: 12px;
    line-height: 1.5;
    font-family: 'SF Mono', 'Fira Code', monospace;
    color: var(--text-muted);
    margin: 12px 0;
  }
  .fol { color: var(--cyan); font-family: 'SF Mono', monospace; font-size: 13px; }
  .badge {
    display: inline-block;
    padding: 2px 8px;
    border-radius: 12px;
    font-size: 11px;
    font-weight: 600;
    margin: 2px;
  }
  .badge-blue { background: rgba(88,166,255,0.2); color: var(--accent); }
  .badge-green { background: rgba(63,185,80,0.2); color: var(--green); }
  .badge-orange { background: rgba(210,153,34,0.2); color: var(--orange); }
  .badge-red { background: rgba(248,81,73,0.2); color: var(--red); }
  .badge-purple { background: rgba(188,140,255,0.2); color: var(--purple); }
  .badge-pink { background: rgba(247,120,186,0.2); color: var(--pink); }
  .badge-cyan { background: rgba(57,210,192,0.2); color: var(--cyan); }
  .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 24px; }
  .grid-3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 16px; }
  .warning { background: rgba(210,153,34,0.1); border-left: 3px solid var(--orange); padding: 12px 16px; margin: 12px 0; border-radius: 0 6px 6px 0; }
  .info { background: rgba(88,166,255,0.1); border-left: 3px solid var(--accent); padding: 12px 16px; margin: 12px 0; border-radius: 0 6px 6px 0; }
  .success { background: rgba(63,185,80,0.1); border-left: 3px solid var(--green); padding: 12px 16px; margin: 12px 0; border-radius: 0 6px 6px 0; }
  .mermaid { margin: 16px 0; }
  @media (max-width: 900px) { .grid-2, .grid-3 { grid-template-columns: 1fr; } }
  .legend { display: flex; gap: 16px; flex-wrap: wrap; margin: 12px 0; font-size: 12px; }
  .legend-item { display: flex; align-items: center; gap: 4px; }
  .legend-dot { width: 12px; height: 12px; border-radius: 50%; }
  .asset-matrix td { font-size: 11px; padding: 4px 8px; }
  .asset-matrix td.yes { background: rgba(63,185,80,0.15); color: var(--green); }
  .asset-matrix td.no { background: rgba(248,81,73,0.05); color: var(--text-muted); }
  .asset-matrix td.opt { background: rgba(210,153,34,0.1); color: var(--orange); }
</style>
</head>
<body>

<div class="header">
  <h1>V4 Formal Graph Rules & Valid Pattern Enumeration</h1>
  <p>All graph construction points, FOL constraints, frontend-derived rules, valid graph patterns per mechanic, and asset type computation</p>
</div>

<div class="tabs">
  <div class="tab active" onclick="showTab('overview')">Overview</div>
  <div class="tab" onclick="showTab('graph-points')">Graph Construction Points</div>
  <div class="tab" onclick="showTab('fol-rules')">FOL Rules</div>
  <div class="tab" onclick="showTab('frontend-constraints')">Frontend Constraints</div>
  <div class="tab" onclick="showTab('scene-graph')">Scene Graph</div>
  <div class="tab" onclick="showTab('mechanic-graph')">Mechanic Transition Graph</div>
  <div class="tab" onclick="showTab('branching-graph')">Branching Decision Graph</div>
  <div class="tab" onclick="showTab('hierarchy-graph')">Hierarchy Tree</div>
  <div class="tab" onclick="showTab('asset-graph')">Asset Graph</div>
  <div class="tab" onclick="showTab('valid-patterns')">Valid Patterns</div>
  <div class="tab" onclick="showTab('asset-matrix')">Asset Type Matrix</div>
  <div class="tab" onclick="showTab('validators')">Validator Checklist</div>
</div>

<!-- TAB 1: OVERVIEW -->
<div id="overview" class="content active">
  <div class="card">
    <h2>Graph Layers in GamED.AI</h2>
    <p>The system constructs <strong>6 distinct graph types</strong> at different pipeline stages. Each has formal rules that determine valid configurations. All must satisfy frontend rendering constraints.</p>
    <div class="mermaid">
graph TB
    subgraph "Layer 1: Scene Graph"
        SG[Scene Graph<br/>Scenes connected by transitions]
    end
    subgraph "Layer 2: Mechanic Transition Graph"
        MG[Per-scene mechanic DAG<br/>Mode transitions between mechanics]
    end
    subgraph "Layer 3: Branching Decision Graph"
        BG[Per-mechanic decision tree<br/>Nodes with choices → next nodes]
    end
    subgraph "Layer 4: Hierarchy Tree"
        HT[Zone parent-child tree<br/>Progressive reveal groups]
    end
    subgraph "Layer 5: Path Graph"
        PG[Ordered waypoint chains<br/>Zone-to-zone trace paths]
    end
    subgraph "Layer 6: Asset Graph"
        AG[Full entity relationship graph<br/>Nodes: game/scene/mechanic/zone/label/asset<br/>Edges: 20+ relation types]
    end
    SG --> MG
    MG --> BG
    SG --> HT
    MG --> PG
    SG --> AG
    MG --> AG
    </div>
  </div>

  <div class="card">
    <h2>Pipeline Agents That Construct Graphs</h2>
    <table>
      <tr><th>Agent</th><th>Graph Layer</th><th>Input</th><th>Output</th><th>Construction Type</th></tr>
      <tr>
        <td><code>game_designer_v3</code></td>
        <td><span class="badge badge-blue">Scene</span> <span class="badge badge-green">Mechanic</span></td>
        <td>User question + domain knowledge</td>
        <td><code>GameDesignV3</code> with scenes[], scene_transitions[], mechanic_transitions[]</td>
        <td>LLM-generated (creative)</td>
      </tr>
      <tr>
        <td><code>scene_architect_v3</code></td>
        <td><span class="badge badge-green">Mechanic</span> <span class="badge badge-purple">Path</span></td>
        <td>GameDesignV3 scenes</td>
        <td><code>SceneSpecV3</code> with mechanic_configs[], zones[]</td>
        <td>LLM-generated (structural)</td>
      </tr>
      <tr>
        <td><code>interaction_designer_v3</code></td>
        <td><span class="badge badge-green">Mechanic</span> <span class="badge badge-orange">Branching</span></td>
        <td>SceneSpecV3 + GameDesignV3</td>
        <td><code>InteractionSpecV3</code> with mode_transitions[], scoring[], feedback[]</td>
        <td>LLM-generated (interactive)</td>
      </tr>
      <tr>
        <td><code>blueprint_assembler_v3</code></td>
        <td><span class="badge badge-red">All layers</span></td>
        <td>All upstream state</td>
        <td><code>InteractiveDiagramBlueprint</code> (frontend-ready)</td>
        <td>Deterministic transform</td>
      </tr>
      <tr>
        <td><code>asset_generator_v3</code></td>
        <td><span class="badge badge-pink">Asset</span></td>
        <td>Visual specs + zone layouts</td>
        <td>Generated images, zone coordinates</td>
        <td>LLM + vision model</td>
      </tr>
    </table>
  </div>
</div>

<!-- TAB 2: GRAPH CONSTRUCTION POINTS -->
<div id="graph-points" class="content">
  <div class="card">
    <h2>Graph Construction Point #1: Scene Graph</h2>
    <h4>Where: <code>game_designer_v3</code> via <code>submit_game_design</code> tool</h4>
    <h4>Schema: <code>GameDesignV3.scenes[]</code> + <code>GameDesignV3.scene_transitions[]</code></h4>
    <pre>
# Scene Graph Construction (game_design_v3.py)
GameDesignV3:
  scenes: List[SceneDesign]        # Nodes
    - scene_number: int (1-indexed, sequential)
    - title: str
    - learning_goal: str
    - zone_labels: List[str]       # Subset of global labels
    - mechanics: List[MechanicDesign]
  scene_transitions: List[SceneTransitionSpec]  # Edges
    - from_scene: int
    - to_scene: int
    - trigger: str (all_complete | score_threshold | time_elapsed)
    - threshold: Optional[float]
    - animation: str
    </pre>
    <div class="info">
      <strong>Construction Rules:</strong><br>
      1. Scene numbers MUST be sequential starting from 1<br>
      2. Transitions can only reference existing scene numbers<br>
      3. Each scene MUST have at least 1 mechanic<br>
      4. Scene zone_labels MUST be subset of global labels
    </div>
  </div>

  <div class="card">
    <h2>Graph Construction Point #2: Mechanic Transition Graph</h2>
    <h4>Where: <code>interaction_designer_v3</code> via <code>enrich_mechanic_content</code> tool</h4>
    <h4>Schema: <code>SceneDesign.mechanic_transitions[]</code> + <code>InteractionSpecV3.mode_transitions[]</code></h4>
    <pre>
# Mechanic Transition Graph (per scene)
MechanicTransitionSpec:
  from_mechanic: str    # mechanic type (drag_drop, trace_path, etc.)
  to_mechanic: str      # mechanic type
  trigger: str          # Trigger condition
  threshold: Optional[float]
  animation: str
  message: Optional[str]

# Frontend receives as:
ModeTransition:
  from: InteractionMode
  to: InteractionMode
  trigger: ModeTransitionTrigger  # 13 valid values
  triggerValue?: number | string[]
  animation?: 'fade' | 'slide' | 'zoom' | 'none'
  message?: string
    </pre>
  </div>

  <div class="card">
    <h2>Graph Construction Point #3: Branching Decision Graph</h2>
    <h4>Where: <code>scene_architect_v3</code> via <code>generate_mechanic_content</code> + <code>blueprint_assembler_v3</code></h4>
    <h4>Schema: <code>BranchingDesign.nodes[]</code> → <code>BranchingConfig.nodes[]</code></h4>
    <pre>
# Backend (BranchingNodeDesign)
BranchingDesign:
  nodes: List[BranchingNodeDesign]
    - id: str
    - prompt: str
    - node_type: decision | info | ending | checkpoint
    - choices: List[BranchingChoiceDesign]
        - text: str
        - next_node_id: Optional[str]  # null = this is an ending path
        - is_correct: Optional[bool]
        - quality: optimal | acceptable | suboptimal | harmful
    - ending_type: good | neutral | bad
  start_node_id: str

# Frontend (DecisionNode)
BranchingConfig:
  nodes: DecisionNode[]
    - id: str
    - question: str
    - options: DecisionOption[]
        - id: str
        - text: str
        - nextNodeId: string | null
        - isCorrect?: boolean
        - consequence?: string
    - isEndNode?: boolean
  startNodeId: str
    </pre>
    <div class="warning">
      <strong>Critical Transform:</strong> Blueprint assembler normalizes <code>prompt</code> → <code>question</code>,
      <code>choices</code> → <code>options</code>, <code>next_node_id</code> → <code>nextNodeId</code>.
      Auto-detects end nodes (no options OR node_type === "ending").
    </div>
  </div>

  <div class="card">
    <h2>Graph Construction Point #4: Hierarchy Tree</h2>
    <h4>Where: <code>game_designer_v3</code> → <code>blueprint_assembler_v3</code></h4>
    <h4>Schema: <code>LabelDesign.hierarchy</code> → <code>ZoneGroup[]</code></h4>
    <pre>
# Backend (HierarchySpec in GameDesignV3)
HierarchySpec:
  enabled: bool
  strategy: str    # "Progressive reveal from chambers to vessels"
  groups: List[HierarchyGroup]
    - parent: str        # Parent label text
    - children: List[str]  # Child label texts
    - reveal_trigger: str  # complete_parent | click_expand | hover_reveal

# Frontend (ZoneGroup in blueprint)
ZoneGroup:
  id: str
  parentZoneId: str      # Zone ID (not label text!)
  childZoneIds: string[] # Zone IDs (not label texts!)
  revealTrigger: 'complete_parent' | 'click_expand' | 'hover_reveal'
  label?: string
    </pre>
  </div>

  <div class="card">
    <h2>Graph Construction Point #5: Path Graph (trace_path)</h2>
    <h4>Where: <code>scene_architect_v3</code> → <code>blueprint_assembler_v3</code></h4>
    <h4>Schema: <code>PathDesign.waypoints</code> → <code>TracePath.waypoints</code></h4>
    <pre>
# Backend (PathDesign)
PathDesign:
  waypoints: List[str]   # Ordered label texts
  path_type: linear | cyclic | branching

# Blueprint assembler transforms label texts → zone IDs:
# waypoint "Right Atrium" → zone_id "zone_1_right_atrium"

# Frontend (TracePath)
TracePath:
  id: string
  waypoints: PathWaypoint[]
    - zoneId: string   # Zone ID
    - order: number    # 0-indexed
  description: string
  requiresOrder: boolean
    </pre>
  </div>

  <div class="card">
    <h2>Graph Construction Point #6: Asset Graph (full entity graph)</h2>
    <h4>Where: <code>asset_graph.py</code> — <code>AssetGraph</code> class</h4>
    <h4>11 node types, 20+ relation types</h4>
    <pre>
NodeType: GAME | SCENE | MECHANIC | IMAGE | ZONE | LABEL | ANIMATION | SOUND | ASSET | THEME | PATH | TRANSITION
RelationType:
  # Containment: CONTAINS, BELONGS_TO
  # Visual: HAS_IMAGE, HAS_BACKGROUND, HAS_OVERLAY, POSITIONED_ON, DECORATES
  # Interaction: OPERATES_ON, TARGETS, AVAILABLE_IN
  # Triggers: TRIGGERS, TRIGGERED_BY
  # Transitions: TRANSITIONS_TO
  # Assets: STYLED_BY, STYLE_REFERENCE, DEPENDS_ON
  # Audio: PLAYS_ON
  # Temporal: REVEALS, BEFORE, AFTER, MUTEX, SEQUENCE
  # Path: HAS_WAYPOINT, FOLLOWS_PATH

# Graph traversal at generation time: topological sort of DEPENDS_ON edges
# Graph serialization to blueprint: asset_graph dict in InteractiveDiagramBlueprint
    </pre>
  </div>
</div>

<!-- TAB 3: FOL RULES -->
<div id="fol-rules" class="content">
  <div class="card">
    <h2>First-Order Logic Rules for Valid Game Graphs</h2>
    <p>These rules define what makes a game graph valid. The pipeline MUST ensure all rules hold. Violations = frontend crash or broken gameplay.</p>
  </div>

  <div class="card">
    <h2>Layer 1: Scene Graph Rules</h2>
    <pre class="fol">
-- R1.1: Sequential scene numbering
∀s ∈ Scenes: s.scene_number ∈ {1, 2, ..., |Scenes|}

-- R1.2: Transition endpoint validity
∀t ∈ SceneTransitions: ∃s₁,s₂ ∈ Scenes:
  t.from_scene = s₁.scene_number ∧ t.to_scene = s₂.scene_number

-- R1.3: No self-transitions
∀t ∈ SceneTransitions: t.from_scene ≠ t.to_scene

-- R1.4: Reachability (for linear progression)
∀s ∈ Scenes where s.scene_number > 1:
  ∃t ∈ SceneTransitions: t.to_scene = s.scene_number
  ∨ progression_type = "linear" (implicit sequential)

-- R1.5: Each scene has mechanics
∀s ∈ Scenes: |s.mechanics| ≥ 1

-- R1.6: Scene zone_labels ⊆ global labels
∀s ∈ Scenes: ∀l ∈ s.zone_labels: l ∈ GlobalLabels.zone_labels ∪ GlobalLabels.group_only_labels

-- R1.7: Single-scene optimization
|Scenes| = 1 → SceneTransitions = ∅ (no transitions needed)
    </pre>
  </div>

  <div class="card">
    <h2>Layer 2: Mechanic Transition Graph Rules</h2>
    <pre class="fol">
-- R2.1: Transition endpoints must exist in scene
∀t ∈ ModeTransitions(scene_s):
  ∃m₁,m₂ ∈ scene_s.mechanics: t.from = m₁.type ∧ t.to = m₂.type

-- R2.2: No self-transitions
∀t ∈ ModeTransitions: t.from ≠ t.to

-- R2.3: Valid trigger types (13 allowed)
∀t ∈ ModeTransitions: t.trigger ∈ {
  all_zones_labeled, path_complete, percentage_complete, specific_zones,
  time_elapsed, user_choice,
  identification_complete, sequence_complete, sorting_complete,
  memory_complete, branching_complete, compare_complete, description_complete
  -- hierarchy_level_complete removed: hierarchical is a mode on drag_drop
}

-- R2.4: Trigger-mechanic compatibility
t.trigger = "path_complete" → t.from = "trace_path"
t.trigger = "all_zones_labeled" → t.from = "drag_drop"  -- hierarchical is a mode on drag_drop
t.trigger = "identification_complete" → t.from = "click_to_identify"
t.trigger = "sequence_complete" → t.from = "sequencing"
t.trigger = "sorting_complete" → t.from = "sorting_categories"
t.trigger = "memory_complete" → t.from = "memory_match"
t.trigger = "branching_complete" → t.from = "branching_scenario"
t.trigger = "compare_complete" → t.from = "compare_contrast"
t.trigger = "description_complete" → t.from = "description_matching"

-- R2.5: Starting mechanic = mechanics[0]
∀s ∈ Scenes: startingMode(s) = s.mechanics[0].type

-- R2.6: DAG property (no cycles in mode transitions)
¬∃ cycle in ModeTransitions(scene_s)  -- avoids infinite loops

-- R2.7: DnD context singleton
-- Only drag_drop needs DnD context; hierarchical is a mode on drag_drop, not a separate mechanic
-- No mutual exclusion issue since only one mechanic type uses DnD
    </pre>
  </div>

  <div class="card">
    <h2>Layer 3: Branching Decision Graph Rules</h2>
    <pre class="fol">
-- R3.1: Start node exists
∀b ∈ BranchingConfigs: ∃n ∈ b.nodes: n.id = b.startNodeId

-- R3.2: All nextNodeId references are valid
∀n ∈ b.nodes, ∀o ∈ n.options:
  o.nextNodeId = null ∨ ∃n₂ ∈ b.nodes: n₂.id = o.nextNodeId

-- R3.3: End nodes have no outgoing edges
∀n ∈ b.nodes where n.isEndNode = true:
  n.options = ∅ ∨ ∀o ∈ n.options: o.nextNodeId = null

-- R3.4: Non-end nodes have options
∀n ∈ b.nodes where n.isEndNode ≠ true:
  |n.options| ≥ 1

-- R3.5: At least one end node reachable from start
∃path from startNode to some n where n.isEndNode = true

-- R3.6: No orphan nodes (all reachable from start)
∀n ∈ b.nodes: reachable(b.startNodeId, n.id)

-- R3.7: Unique node IDs
∀n₁,n₂ ∈ b.nodes: n₁ ≠ n₂ → n₁.id ≠ n₂.id

-- R3.8: Completion condition
isComplete(branching) ↔ currentNode.isEndNode = true

-- R3.9: Runtime safety
¬∃n ∈ reachable(startNode): nodes.find(n.id) = null
  -- If node not found at runtime → graceful error render (not crash)
  -- BranchingScenario.tsx line 163: renders "Error: Node not found"
    </pre>
  </div>

  <div class="card">
    <h2>Layer 4: Hierarchy Tree Rules</h2>
    <pre class="fol">
-- R4.1: Tree structure (no cycles)
∀z ∈ Zones: ¬ancestor(z, z)  -- zone cannot be its own ancestor

-- R4.2: Parent zones must exist
∀g ∈ ZoneGroups: ∃z ∈ Zones: z.id = g.parentZoneId

-- R4.3: Child zones must exist
∀g ∈ ZoneGroups, ∀c ∈ g.childZoneIds: ∃z ∈ Zones: z.id = c

-- R4.4: No zone appears as child in multiple groups
∀z_id: |{g ∈ ZoneGroups : z_id ∈ g.childZoneIds}| ≤ 1

-- R4.5: Parent labels ∈ group_only_labels
∀g ∈ HierarchyGroups: g.parent ∈ group_only_labels

-- R4.6: Child labels ∈ zone_labels
∀g ∈ HierarchyGroups, ∀c ∈ g.children: c ∈ zone_labels

-- R4.7: Depth constraint (practical limit)
max_depth(hierarchy) ≤ 4  -- frontend renders up to ~4 levels

-- R4.8: HierarchyState progression
completedParentZones grows monotonically
expandedGroups grows monotonically
    </pre>
  </div>

  <div class="card">
    <h2>Layer 5: Path Graph Rules</h2>
    <pre class="fol">
-- R5.1: Waypoints reference valid zones with coordinates
∀p ∈ Paths, ∀w ∈ p.waypoints: ∃z ∈ Zones: z.id = w.zoneId ∧ z.x ≠ null ∧ z.y ≠ null

-- R5.2: Waypoint order is sequential (0-indexed)
∀p ∈ Paths: p.waypoints[i].order = i  for i = 0..len-1

-- R5.3: At least 2 waypoints per path
∀p ∈ Paths: |p.waypoints| ≥ 2

-- R5.4: No duplicate zones in a single path
∀p ∈ Paths: ∀w₁,w₂ ∈ p.waypoints: w₁ ≠ w₂ → w₁.zoneId ≠ w₂.zoneId
  -- Exception: cyclic paths where first = last

-- R5.5: Path completion
isComplete(path_p) ↔ ∀entry ∈ pathProgressMap: entry.isComplete = true
    </pre>
  </div>

  <div class="card">
    <h2>Cross-Layer Integrity Rules</h2>
    <pre class="fol">
-- R6.1: Label-Zone bijection (for drag_drop)
∀l ∈ Labels: ∃!z ∈ Zones: l.correctZoneId = z.id
∀z ∈ Zones where ¬z.group_only: ∃l ∈ Labels: l.correctZoneId = z.id

-- R6.2: Mechanic zone_labels_used ⊆ scene zone_labels
∀m ∈ Mechanics: ∀l ∈ m.zone_labels_used: l ∈ scene.zone_labels

-- R6.3: Distractor labels disjoint from correct labels
∀d ∈ DistractorLabels: d.id ∉ {l.id : l ∈ Labels}

-- R6.4: Score consistency
∑(mechanic.scoring.max_score) = scene.max_score
∑(scene.max_score) = game.total_max_score

-- R6.5: Temporal constraint zone existence
∀tc ∈ TemporalConstraints: ∃z₁,z₂ ∈ Zones:
  z₁.label = tc.zone_a ∧ z₂.label = tc.zone_b

-- R6.6: ID uniqueness (global)
All zone IDs unique within a scene
All label IDs unique within a scene
All mechanic IDs unique within a scene
All scene IDs unique globally
    </pre>
  </div>
</div>

<!-- TAB 4: FRONTEND CONSTRAINTS -->
<div id="frontend-constraints" class="content">
  <div class="card">
    <h2>Frontend Rendering Constraints (from mechanicRegistry.ts)</h2>
    <p>These constraints are derived from how the frontend <code>MECHANIC_REGISTRY</code> validates, initializes, and checks completion for each mechanic. If the backend produces data that violates these, the mechanic either crashes or silently fails.</p>
  </div>

  <div class="card">
    <h2>Per-Mechanic Config Requirements</h2>
    <table>
      <tr>
        <th>Mechanic</th>
        <th>configKey</th>
        <th>validateConfig Rule</th>
        <th>isComplete Condition</th>
        <th>needsDndContext</th>
      </tr>
      <tr>
        <td><code>drag_drop</code></td>
        <td><code>dragDropConfig</code></td>
        <td><code>labels.length > 0</code> (diagram.width/height defaults 800×600 if absent)</td>
        <td><code>placedCorrect >= taskLabelCount</code></td>
        <td>YES</td>
      </tr>
      <tr>
        <td><code>click_to_identify</code></td>
        <td><code>clickToIdentifyConfig</code></td>
        <td><code>identificationPrompts.length > 0</code></td>
        <td><code>currentPromptIndex >= totalPrompts</code></td>
        <td>no</td>
      </tr>
      <tr>
        <td><code>trace_path</code></td>
        <td><code>tracePathConfig</code></td>
        <td><code>paths.length > 0 AND ∀path.waypoints[].zoneId resolves to zone with valid x/y coordinates</code></td>
        <td><code>all pathProgressMap entries isComplete</code></td>
        <td>no</td>
      </tr>
      <tr>
        <td><code>sequencing</code></td>
        <td><code>sequenceConfig</code></td>
        <td><code>sequenceConfig.items.length > 0</code></td>
        <td><code>isSubmitted AND correctPositions === totalPositions</code></td>
        <td>no</td>
      </tr>
      <tr>
        <td><code>sorting_categories</code></td>
        <td><code>sortingConfig</code></td>
        <td><code>items AND categories exist</code></td>
        <td><code>isSubmitted AND correctCount === totalCount</code></td>
        <td>no</td>
      </tr>
      <tr>
        <td><code>memory_match</code></td>
        <td><code>memoryMatchConfig</code></td>
        <td><code>config ≠ null AND pairs ≠ null AND pairs.length > 0</code></td>
        <td><code>matchedPairIds.length >= totalPairs</code></td>
        <td>no</td>
      </tr>
      <tr>
        <td><code>branching_scenario</code></td>
        <td><code>branchingConfig</code></td>
        <td><code>nodes AND startNodeId exist AND nodes.find(startNodeId) ≠ null</code></td>
        <td><code>currentNode.isEndNode === true</code> (graceful error render if node not found)</td>
        <td>no</td>
      </tr>
      <tr>
        <td><code>compare_contrast</code></td>
        <td><code>compareConfig</code></td>
        <td><code>diagramA ≠ null AND diagramB ≠ null AND diagramA.zones[].{x,y,width,height} AND diagramB.zones[].{x,y,width,height}</code></td>
        <td><code>isSubmitted AND correctCount === totalCount</code></td>
        <td>no</td>
      </tr>
      <tr>
        <td><code>description_matching</code></td>
        <td><code>descriptionMatchingConfig</code></td>
        <td>zones with descriptions (implicit)</td>
        <td><code>currentIndex >= totalDescriptions</code></td>
        <td>no</td>
      </tr>
      <!-- hierarchical is a MODE (progressive reveal), not a mechanic.
           It operates as a zone-grouping layer on top of drag_drop.
           Requires: zoneGroups[] with valid parentZoneId/childZoneIds, zones with coordinates. -->
      <tr>
        <td colspan="5" style="color: var(--text-muted); font-style: italic;">
          <code>hierarchical</code> is a <strong>mode</strong> (progressive reveal layer on drag_drop), not a standalone mechanic.
          Requires <code>zoneGroups[]</code> with valid zone references + zones with coordinate data.
        </td>
      </tr>
    </table>
  </div>

  <div class="card">
    <h2>Blueprint Shape Constraints</h2>
    <p>The frontend <code>InteractiveDiagramBlueprint</code> type defines exactly what shape the blueprint must have. Any deviation = crash.</p>
    <div class="grid-2">
      <div>
        <h3>Always Required</h3>
        <pre>
templateType: 'INTERACTIVE_DIAGRAM'  // exact
title: string                         // non-empty
diagram.zones: Zone[]                 // for zone-based mechanics
labels: Label[]                       // for drag_drop/hierarchical
  - id: string
  - text: string
  - correctZoneId: string  // MUST match a zone.id
animationCues: AnimationCues
  - correctPlacement: string
  - incorrectPlacement: string
        </pre>
      </div>
      <div>
        <h3>Per-Mechanic Required</h3>
        <pre>
drag_drop:       labels[].correctZoneId
click_to_identify: identificationPrompts[]
trace_path:      paths[].waypoints[] (zones need x/y)
sequencing:      sequenceConfig.items[] + correctOrder[]
sorting:         sortingConfig.items[] + categories[]
memory_match:    memoryMatchConfig (≠ null) + pairs[]
branching:       branchingConfig.nodes[] + startNodeId
compare:         compareConfig.diagramA + diagramB (zones need x/y/w/h)
description:     zones[].description (non-empty)
-- hierarchical is a MODE on drag_drop, not a mechanic
-- requires: zoneGroups[] + labels[] + zones with coords
        </pre>
      </div>
    </div>
  </div>

  <div class="card">
    <h2>Zone Shape Constraints</h2>
    <table>
      <tr><th>Shape</th><th>Required Fields</th><th>Auto-Detection Rule</th></tr>
      <tr>
        <td><code>circle</code></td>
        <td><code>x</code>, <code>y</code>, <code>radius</code> (0-100%)</td>
        <td>Default when no points data</td>
      </tr>
      <tr>
        <td><code>polygon</code></td>
        <td><code>points: [number, number][]</code> (min 3 vertices, 0-100%)</td>
        <td>Auto-set when points array has 3+ entries</td>
      </tr>
      <tr>
        <td><code>rect</code></td>
        <td><code>x</code>, <code>y</code>, <code>width</code>, <code>height</code> (0-100%)</td>
        <td>Never auto-detected, must be explicit</td>
      </tr>
    </table>
    <div class="warning">
      <strong>Coordinate transform:</strong> Backend zone detection returns absolute pixels. Blueprint assembler normalizes to 0-100% percentages.
      <code>_postprocess_zones()</code> flattens nested <code>coordinates</code> dict into top-level fields and computes center from polygon points.
    </div>
  </div>

  <div class="card">
    <h2>DnD Context Rule</h2>
    <p>Only <code>drag_drop</code> requires DnD context (wrapped in <code>&lt;DndContext&gt;</code>).
    <code>hierarchical</code> is a mode/layer on top of drag_drop (progressive reveal of zone groups), not a standalone mechanic.</p>
  </div>
</div>

<!-- TAB 5: SCENE GRAPH -->
<div id="scene-graph" class="content">
  <div class="card">
    <h2>Scene Graph — Valid Topologies</h2>
    <div class="grid-2">
      <div>
        <h3>Linear (most common)</h3>
        <div class="mermaid">
graph LR
    S1[Scene 1] -->|all_complete| S2[Scene 2] -->|all_complete| S3[Scene 3]
        </div>
        <pre class="fol">progression_type = "linear"
∀i ∈ {1..n-1}: transition(i, i+1, all_complete)</pre>
      </div>
      <div>
        <h3>Zoom-in (progressive detail)</h3>
        <div class="mermaid">
graph TB
    S1[Scene 1: Overview] -->|click_zone| S2[Scene 2: Detail A]
    S1 -->|click_zone| S3[Scene 3: Detail B]
    S2 -->|all_complete| S4[Scene 4: Summary]
    S3 -->|all_complete| S4
        </div>
        <pre class="fol">progression_type = "zoom_in"
∃fork: transition(1, 2) ∧ transition(1, 3)
∃join: transition(2, 4) ∧ transition(3, 4)</pre>
      </div>
    </div>
    <div class="grid-2">
      <div>
        <h3>Branching</h3>
        <div class="mermaid">
graph TB
    S1[Scene 1] -->|score ≥ 80| S2A[Scene 2A: Advanced]
    S1 -->|score < 80| S2B[Scene 2B: Remedial]
    S2A -->|all_complete| S3[Scene 3]
    S2B -->|all_complete| S3
        </div>
        <pre class="fol">progression_type = "branching"
∃s₁: |{t: t.from_scene = s₁}| > 1  (fork point)</pre>
      </div>
      <div>
        <h3>Single Scene (most V3 games)</h3>
        <div class="mermaid">
graph LR
    S1[Scene 1 — All mechanics here]
        </div>
        <pre class="fol">|Scenes| = 1
SceneTransitions = ∅
All mechanics chain via ModeTransitions</pre>
      </div>
    </div>
  </div>
</div>

<!-- TAB 6: MECHANIC TRANSITION GRAPH -->
<div id="mechanic-graph" class="content">
  <div class="card">
    <h2>Mechanic Transition Graph — Valid Patterns</h2>
    <p>Within a single scene, mechanics are ordered. mechanics[0] is the starting mode. Transitions define a DAG.</p>
  </div>
  <div class="card">
    <h3>Common Multi-Mechanic Patterns</h3>
    <div class="grid-2">
      <div>
        <h4>Pattern A: Linear Chain (2-3 mechanics)</h4>
        <div class="mermaid">
graph LR
    DD[drag_drop] -->|all_zones_labeled| CTI[click_to_identify] -->|identification_complete| TP[trace_path]
        </div>
        <pre>Example: "Label the heart, then identify functions, then trace blood flow"</pre>
      </div>
      <div>
        <h4>Pattern B: Fork-Join</h4>
        <div class="mermaid">
graph TB
    DD[drag_drop] -->|all_zones_labeled| SEQ[sequencing]
    DD -->|all_zones_labeled| DM[description_matching]
    SEQ -->|sequence_complete| CC[compare_contrast]
    DM -->|description_complete| CC
        </div>
        <pre>Example: "Label, then sequence OR describe, then compare"</pre>
      </div>
    </div>
    <div class="grid-2">
      <div>
        <h4>Pattern C: Progressive Depth (hierarchy mode)</h4>
        <div class="mermaid">
graph LR
    DD["drag_drop<br/>(hierarchy mode)"] -->|all_zones_labeled| TP[trace_path]
        </div>
        <pre>Example: "Label main parts with progressive reveal of sub-parts, then trace connections"
Note: hierarchy is a mode on drag_drop (via zoneGroups), not a separate mechanic</pre>
      </div>
      <div>
        <h4>Pattern D: Single Mechanic (most common)</h4>
        <div class="mermaid">
graph LR
    DD[drag_drop]
        </div>
        <pre>No transitions needed. mechanics = [drag_drop]. Game ends on completion.</pre>
      </div>
    </div>
  </div>

  <div class="card">
    <h3>Mechanic Compatibility Matrix</h3>
    <p>Which mechanics can follow which? Based on frontend trigger compatibility and pedagogical sense.</p>
    <table>
      <tr>
        <th>From \ To</th>
        <th>drag_drop</th><th>click_id</th><th>trace</th><th>seq</th><th>sort</th>
        <th>memory</th><th>branch</th><th>compare</th><th>desc</th>
      </tr>
      <tr><td><strong>drag_drop</strong></td>      <td>-</td><td class="yes">Y</td><td class="yes">Y</td><td class="yes">Y</td><td class="yes">Y</td><td class="yes">Y</td><td class="yes">Y</td><td class="yes">Y</td><td class="yes">Y</td></tr>
      <tr><td><strong>click_to_identify</strong></td><td class="yes">Y</td><td>-</td><td class="yes">Y</td><td class="opt">O</td><td class="opt">O</td><td class="opt">O</td><td class="opt">O</td><td class="opt">O</td><td class="yes">Y</td></tr>
      <tr><td><strong>trace_path</strong></td>      <td class="opt">O</td><td class="yes">Y</td><td>-</td><td class="opt">O</td><td class="no">N</td><td class="no">N</td><td class="opt">O</td><td class="opt">O</td><td class="opt">O</td></tr>
      <tr><td><strong>sequencing</strong></td>       <td class="opt">O</td><td class="opt">O</td><td class="opt">O</td><td>-</td><td class="opt">O</td><td class="opt">O</td><td class="opt">O</td><td class="yes">Y</td><td class="opt">O</td></tr>
      <tr><td><strong>sorting</strong></td>          <td class="opt">O</td><td class="opt">O</td><td class="no">N</td><td class="opt">O</td><td>-</td><td class="opt">O</td><td class="opt">O</td><td class="yes">Y</td><td class="opt">O</td></tr>
      <tr><td><strong>memory_match</strong></td>     <td class="opt">O</td><td class="opt">O</td><td class="no">N</td><td class="opt">O</td><td class="opt">O</td><td>-</td><td class="opt">O</td><td class="opt">O</td><td class="opt">O</td></tr>
      <tr><td><strong>branching</strong></td>        <td class="no">N</td><td class="opt">O</td><td class="no">N</td><td class="no">N</td><td class="no">N</td><td class="no">N</td><td>-</td><td class="opt">O</td><td class="no">N</td></tr>
      <tr><td><strong>compare</strong></td>          <td class="opt">O</td><td class="opt">O</td><td class="no">N</td><td class="opt">O</td><td class="opt">O</td><td class="opt">O</td><td class="opt">O</td><td>-</td><td class="opt">O</td></tr>
      <tr><td><strong>description</strong></td>      <td class="yes">Y</td><td class="yes">Y</td><td class="opt">O</td><td class="opt">O</td><td class="opt">O</td><td class="opt">O</td><td class="opt">O</td><td class="opt">O</td><td>-</td></tr>
    </table>
    <div class="legend">
      <div class="legend-item"><span class="badge badge-green">Y</span> = Natural flow</div>
      <div class="legend-item"><span class="badge badge-orange">O</span> = Possible but unusual</div>
      <div class="legend-item"><span class="badge badge-red">N</span> = Anti-pattern (avoid)</div>
    </div>
    <div class="info">
      <strong>Key constraint:</strong> Only <code>drag_drop</code> needs DnD context (<code>hierarchical</code> is a mode/layer on drag_drop, not a separate mechanic).
      <code>branching_scenario</code> is terminal — it consumes the rest of the game as a narrative. Rarely chains to anything.
    </div>
  </div>
</div>

<!-- TAB 7: BRANCHING DECISION GRAPH -->
<div id="branching-graph" class="content">
  <div class="card">
    <h2>Branching Decision Graph — Valid Topologies</h2>
  </div>
  <div class="card">
    <h3>Pattern A: Linear with Consequences</h3>
    <div class="mermaid">
graph TB
    N1[Node 1: Initial Scenario] -->|Choice A - correct| N2[Node 2: Good Outcome]
    N1 -->|Choice B - wrong| N3[Node 3: Bad Outcome]
    N2 -->|Choice C| N4[END: Success]
    N3 -->|Choice D| N5[END: Partial Success]
    style N4 fill:#22c55e,color:#000
    style N5 fill:#f59e0b,color:#000
    </div>
    <pre class="fol">narrative_structure = "linear"
max_depth = 3, branch_factor = 2
∀path: length(path) ≤ 3</pre>
  </div>
  <div class="card">
    <h3>Pattern B: Foldback (converging branches)</h3>
    <div class="mermaid">
graph TB
    N1[Node 1] -->|A| N2[Node 2A]
    N1 -->|B| N3[Node 2B]
    N2 -->|C| N4[Node 3: Convergence]
    N3 -->|D| N4
    N4 -->|E| N5[END]
    style N5 fill:#22c55e,color:#000
    </div>
    <pre class="fol">narrative_structure = "foldback"
∃n: in_degree(n) > 1  (convergence point)
Reduces total end nodes</pre>
  </div>
  <div class="card">
    <h3>Pattern C: Full Branching Tree</h3>
    <div class="mermaid">
graph TB
    N1[Start] -->|A| N2[2A]
    N1 -->|B| N3[2B]
    N2 -->|C| N4[END: Good]
    N2 -->|D| N5[END: Neutral]
    N3 -->|E| N6[END: Bad]
    N3 -->|F| N7[END: Worst]
    style N4 fill:#22c55e,color:#000
    style N5 fill:#f59e0b,color:#000
    style N6 fill:#f85149,color:#000
    style N7 fill:#f85149,color:#000
    </div>
    <pre class="fol">narrative_structure = "branching"
|end_nodes| = branch_factor ^ depth
Exponential growth — keep depth ≤ 3</pre>
  </div>
  <div class="card">
    <h3>Practical Bounds</h3>
    <table>
      <tr><th>Parameter</th><th>Recommended</th><th>Maximum</th><th>Reason</th></tr>
      <tr><td>Total nodes</td><td>5-8</td><td>15</td><td>LLM quality degrades beyond ~10 nodes</td></tr>
      <tr><td>Max depth</td><td>3</td><td>5</td><td>User engagement drops after 5 decisions</td></tr>
      <tr><td>Branch factor</td><td>2-3</td><td>4</td><td>Frontend renders options as buttons</td></tr>
      <tr><td>End nodes</td><td>2-4</td><td>8</td><td>Scoring complexity</td></tr>
      <tr><td>Foldback ratio</td><td>30-50%</td><td>80%</td><td>Too much foldback = not really branching</td></tr>
    </table>
  </div>
</div>

<!-- TAB 8: HIERARCHY TREE -->
<div id="hierarchy-graph" class="content">
  <div class="card">
    <h2>Hierarchy Tree — Valid Topologies</h2>
    <div class="warning">
      <strong>Note:</strong> Hierarchical is a <strong>mode</strong> (progressive reveal layer) on drag_drop, not a standalone mechanic.
      It uses <code>zoneGroups[]</code> to define parent-child zone relationships, enabling progressive reveal of zones.
    </div>
  </div>
  <div class="card">
    <h3>2-Level Hierarchy (standard)</h3>
    <div class="mermaid">
graph TB
    H[Heart - group_only] --> LA[Left Atrium]
    H --> LV[Left Ventricle]
    H --> RA[Right Atrium]
    H --> RV[Right Ventricle]
    V[Valves - group_only] --> MV[Mitral Valve]
    V --> TV[Tricuspid Valve]
    style H fill:#bc8cff,color:#000
    style V fill:#bc8cff,color:#000
    </div>
    <pre>
hierarchy:
  enabled: true
  groups:
    - parent: "Heart"
      children: ["Left Atrium", "Left Ventricle", "Right Atrium", "Right Ventricle"]
      reveal_trigger: "complete_parent"
    - parent: "Valves"
      children: ["Mitral Valve", "Tricuspid Valve"]
      reveal_trigger: "complete_parent"
    </pre>
    <div class="info">
      <strong>Frontend behavior:</strong> Group-only zones appear first. When user labels all parent zones,
      child zones are revealed. <code>HierarchyController</code> manages the progressive reveal.
    </div>
  </div>
  <div class="card">
    <h3>3-Level Deep Hierarchy</h3>
    <div class="mermaid">
graph TB
    Cell[Cell - L1] --> Nucleus[Nucleus - L2]
    Cell --> Cytoplasm[Cytoplasm - L2]
    Nucleus --> Chromatin[Chromatin - L3]
    Nucleus --> Nucleolus[Nucleolus - L3]
    Cytoplasm --> Mitochondria[Mitochondria - L3]
    Cytoplasm --> ER[Endoplasmic Reticulum - L3]
    style Cell fill:#bc8cff,color:#000
    style Nucleus fill:#58a6ff,color:#000
    style Cytoplasm fill:#58a6ff,color:#000
    </div>
    <pre class="fol">max_depth = 3
L1 zones: group_only = true, hierarchyLevel = 1
L2 zones: can be group_only OR labelable, hierarchyLevel = 2
L3 zones: labelable, hierarchyLevel = 3
    </pre>
  </div>
</div>

<!-- TAB 9: ASSET GRAPH -->
<div id="asset-graph" class="content">
  <div class="card">
    <h2>Asset Graph — Full Entity Relationship Model</h2>
    <p>The <code>AssetGraph</code> in <code>asset_graph.py</code> encodes ALL game entities and their relationships as a typed graph.</p>
    <div class="mermaid">
graph TB
    subgraph "Containment Hierarchy"
        GAME[GameNode] -->|CONTAINS| SCENE[SceneNode]
        SCENE -->|CONTAINS| MECH[MechanicNode]
        SCENE -->|HAS_IMAGE| IMG[ImageNode]
        IMG -->|POSITIONED_ON| ZONE[ZoneNode]
    end
    subgraph "Interaction Logic"
        MECH -->|OPERATES_ON| ZONE
        LABEL[LabelNode] -->|TARGETS| ZONE
        LABEL -->|AVAILABLE_IN| MECH
    end
    subgraph "Visual Composition"
        SCENE -->|HAS_BACKGROUND| BG[AssetNode:bg]
        SCENE -->|DECORATES| DEC[AssetNode:deco]
        IMG -->|HAS_OVERLAY| OVL[AssetNode:overlay]
    end
    subgraph "Theming"
        GAME -->|STYLED_BY| THEME[ThemeNode]
        DEC -->|STYLE_REFERENCE| IMG
    end
    subgraph "Temporal"
        ZONE -->|REVEALS| CHILD[ZoneNode:child]
        ZONE -->|BEFORE| ZONE2[ZoneNode:next]
    end
    subgraph "Paths"
        PATH[PathNode] -->|HAS_WAYPOINT| ZONE
        MECH -->|FOLLOWS_PATH| PATH
    end
    </div>
  </div>
  <div class="card">
    <h3>Generation Order via Topological Sort</h3>
    <pre>
1. ThemeNode (no deps)
2. ImageNode per scene (depends on ThemeNode for style)
3. ZoneNode per scene (depends on ImageNode — zone detection)
4. BackgroundAsset per scene (depends on ThemeNode)
5. OverlayAsset per zone (depends on ImageNode + ZoneNode)
6. AnimationNode (depends on zone/mechanic events)
7. SoundNode (depends on event types)

DEPENDS_ON edges define the generation DAG.
    </pre>
  </div>
</div>

<!-- TAB 10: VALID PATTERNS -->
<div id="valid-patterns" class="content">
  <div class="card">
    <h2>Complete Enumeration of Valid Game Configurations</h2>
    <p>For each mechanic, what combinations are valid? Computed from frontend constraints + backend schemas.</p>
  </div>

  <div class="card">
    <h2>drag_drop — Valid Configurations</h2>
    <table>
      <tr><th>Config Field</th><th>Valid Values</th><th>Default</th></tr>
      <tr><td>interaction_mode</td><td><code>drag_drop</code> | <code>click_to_place</code> | <code>reverse</code></td><td><code>drag_drop</code></td></tr>
      <tr><td>feedback_timing</td><td><code>immediate</code> | <code>deferred</code></td><td><code>immediate</code></td></tr>
      <tr><td>leader_line_style</td><td><code>straight</code> | <code>elbow</code> | <code>curved</code> | <code>fluid</code> | <code>none</code></td><td><code>none</code></td></tr>
      <tr><td>tray_position</td><td><code>bottom</code> | <code>right</code> | <code>left</code> | <code>top</code></td><td><code>bottom</code></td></tr>
      <tr><td>tray_layout</td><td><code>horizontal</code> | <code>vertical</code> | <code>grid</code> | <code>grouped</code></td><td><code>horizontal</code></td></tr>
      <tr><td>label_style</td><td><code>text</code> | <code>text_with_icon</code> | <code>text_with_thumbnail</code> | <code>text_with_description</code></td><td><code>text</code></td></tr>
      <tr><td>pin_marker_shape</td><td><code>circle</code> | <code>diamond</code> | <code>arrow</code> | <code>none</code></td><td><code>none</code></td></tr>
    </table>
    <pre class="fol">
-- Required data
|labels| ≥ 3           -- pedagogically useful minimum
|zones| = |labels|     -- bijection (for correct labels)
∀l: l.correctZoneId ∈ {z.id : z ∈ zones}
diagram.width defaults to 800, diagram.height defaults to 600 if absent

-- Optional
distractorLabels: 0 to |labels|
max_attempts: 0 (unlimited) to 10
zoneGroups[]: enables hierarchy mode (progressive reveal)
    </pre>
    <div class="success">
      <strong>Total valid configs:</strong> 3 × 2 × 5 × 4 × 4 × 4 × 4 = <strong>7,680</strong> visual variations
    </div>
  </div>

  <div class="card">
    <h2>sequencing — Valid Configurations</h2>
    <table>
      <tr><th>Config Field</th><th>Valid Values</th><th>Default</th></tr>
      <tr><td>sequenceType</td><td><code>linear</code> | <code>cyclic</code> | <code>branching</code></td><td><code>linear</code></td></tr>
      <tr><td>layout_mode</td><td><code>horizontal_timeline</code> | <code>vertical_list</code> | <code>circular_cycle</code> | <code>flowchart</code> | <code>insert_between</code></td><td><code>horizontal_timeline</code></td></tr>
      <tr><td>interaction_pattern</td><td><code>drag_reorder</code> | <code>drag_to_slots</code> | <code>click_to_swap</code> | <code>number_typing</code></td><td><code>drag_reorder</code></td></tr>
      <tr><td>card_type</td><td><code>text_only</code> | <code>text_with_icon</code> | <code>image_with_caption</code> | <code>image_only</code></td><td><code>text_only</code></td></tr>
      <tr><td>connector_style</td><td><code>arrow</code> | <code>line</code> | <code>numbered</code> | <code>none</code></td><td><code>arrow</code></td></tr>
    </table>
    <pre class="fol">
|items| ≥ 3                    -- minimum for meaningful sequence
|correctOrder| = |items|       -- every item has a position
∀id ∈ correctOrder: ∃item: item.id = id
sequenceType = "cyclic" → layout_mode should be "circular_cycle"
    </pre>
    <div class="success"><strong>Total valid configs:</strong> 3 × 5 × 4 × 4 × 4 = <strong>960</strong></div>
  </div>

  <div class="card">
    <h2>sorting_categories — Valid Configurations</h2>
    <table>
      <tr><th>Config Field</th><th>Valid Values</th><th>Default</th></tr>
      <tr><td>sort_mode</td><td><code>bucket</code> | <code>venn_2</code> | <code>venn_3</code> | <code>matrix</code> | <code>column</code></td><td><code>bucket</code></td></tr>
      <tr><td>item_card_type</td><td><code>text_only</code> | <code>text_with_icon</code> | <code>image_with_caption</code></td><td><code>text_only</code></td></tr>
      <tr><td>container_style</td><td><code>bucket</code> | <code>labeled_bin</code> | <code>circle</code> | <code>cell</code> | <code>column</code></td><td><code>bucket</code></td></tr>
      <tr><td>submit_mode</td><td><code>batch_submit</code> | <code>immediate_feedback</code> | <code>round_based</code></td><td><code>batch_submit</code></td></tr>
    </table>
    <pre class="fol">
|categories| ≥ 2
|items| ≥ |categories|         -- at least one item per category
∀item: |item.correct_category_ids| ≥ 1  -- multi-category items allowed (e.g. Venn overlap)
∀item: ∀cat_id ∈ item.correct_category_ids: ∃cat: cat.id = cat_id
sort_mode = "venn_2" → |categories| = 2
sort_mode = "venn_3" → |categories| = 3
-- Completion: isSubmitted ∧ ∀item: item.currentCategoryId ∈ item.correct_category_ids
    </pre>
    <div class="success"><strong>Total valid configs:</strong> 5 × 3 × 5 × 3 = <strong>225</strong></div>
  </div>

  <div class="card">
    <h2>memory_match — Valid Configurations</h2>
    <table>
      <tr><th>Config Field</th><th>Valid Values</th><th>Default</th></tr>
      <tr><td>game_variant</td><td><code>classic</code> | <code>column_match</code> | <code>scatter</code> | <code>progressive</code> | <code>peek</code></td><td><code>classic</code></td></tr>
      <tr><td>match_type</td><td><code>term_to_definition</code> | <code>image_to_label</code> | <code>diagram_region_to_label</code> | <code>concept_to_example</code></td><td><code>term_to_definition</code></td></tr>
      <tr><td>card_back_style</td><td><code>solid</code> | <code>gradient</code> | <code>pattern</code> | <code>question_mark</code></td><td><code>pattern</code></td></tr>
      <tr><td>matched_card_behavior</td><td><code>fade</code> | <code>shrink</code> | <code>collect</code> | <code>checkmark</code></td><td><code>fade</code></td></tr>
    </table>
    <pre class="fol">
config ≠ null                  -- EnhancedMemoryMatch crashes if config is null (line 521)
config.pairs ≠ null ∧ |pairs| ≥ 3  -- minimum for a game
∀pair: pair.front ≠ "" ∧ pair.back ≠ ""
gridSize[0] × gridSize[1] ≥ |pairs| × 2
∀pair: pair.id is unique
    </pre>
    <div class="success"><strong>Total valid configs:</strong> 5 × 4 × 4 × 4 = <strong>320</strong></div>
  </div>

  <div class="card">
    <h2>branching_scenario — Valid Configurations</h2>
    <table>
      <tr><th>Config Field</th><th>Valid Values</th><th>Default</th></tr>
      <tr><td>narrative_structure</td><td><code>linear</code> | <code>branching</code> | <code>foldback</code></td><td><code>linear</code></td></tr>
      <tr><td>showPathTaken</td><td><code>true</code> | <code>false</code></td><td><code>true</code></td></tr>
      <tr><td>allowBacktrack</td><td><code>true</code> | <code>false</code></td><td><code>false</code></td></tr>
      <tr><td>showConsequences</td><td><code>true</code> | <code>false</code></td><td><code>true</code></td></tr>
      <tr><td>multipleValidEndings</td><td><code>true</code> | <code>false</code></td><td><code>false</code></td></tr>
    </table>
    <pre class="fol">
|nodes| ≥ 2                   -- at least start + end
∃n: n.id = startNodeId        -- start exists
∃n: n.isEndNode = true         -- at least one ending
∀n where ¬n.isEndNode: |n.options| ≥ 1
∀o: o.nextNodeId ∈ {n.id} ∪ {null}
reachable(startNodeId, some_end_node)
    </pre>
    <div class="success"><strong>Total valid configs:</strong> 3 × 2⁴ = <strong>48</strong> structural variations</div>
  </div>

  <div class="card">
    <h2>compare_contrast — Valid Configurations</h2>
    <table>
      <tr><th>Config Field</th><th>Valid Values</th><th>Default</th></tr>
      <tr><td>comparison_mode</td><td><code>side_by_side</code> | <code>slider</code> | <code>overlay_toggle</code> | <code>venn</code> | <code>spot_difference</code></td><td><code>side_by_side</code></td></tr>
      <tr><td>category_types</td><td><code>[similar, different, unique_a, unique_b]</code></td><td>all four</td></tr>
    </table>
    <pre class="fol">
diagramA ≠ null ∧ diagramB ≠ null
diagramA.id ≠ null ∧ diagramA.name ≠ null ∧ diagramA.imageUrl ≠ null
diagramB.id ≠ null ∧ diagramB.name ≠ null ∧ diagramB.imageUrl ≠ null
∀z ∈ diagramA.zones ∪ diagramB.zones: z.x ≠ null ∧ z.y ≠ null ∧ z.width ≠ null ∧ z.height ≠ null
|expectedCategories| ≥ 1
∀zone_id ∈ expectedCategories.keys:
  zone_id ∈ {z.id : z ∈ diagramA.zones ∪ diagramB.zones}
    </pre>
    <div class="success"><strong>Total valid configs:</strong> 5 comparison modes × (2⁴ - 1) category subsets = <strong>75</strong></div>
  </div>
</div>

<!-- TAB 11: ASSET TYPE MATRIX -->
<div id="asset-matrix" class="content">
  <div class="card">
    <h2>Asset Types Required Per Mechanic</h2>
    <p>For every mechanic, what backend data structures and frontend config fields are needed?</p>
    <table class="asset-matrix">
      <tr>
        <th>Asset / Data Type</th>
        <th>drag_drop</th><th>click_id</th><th>trace</th><th>seq</th><th>sort</th>
        <th>memory</th><th>branch</th><th>compare</th><th>desc</th>
      </tr>
      <tr>
        <td><strong>Diagram image</strong></td>
        <td class="yes">REQ</td><td class="yes">REQ</td><td class="yes">REQ</td>
        <td class="no">-</td><td class="no">-</td><td class="no">-</td>
        <td class="opt">OPT</td><td class="yes">REQ×2</td><td class="yes">REQ</td>
      </tr>
      <tr>
        <td><strong>Zone coordinates</strong></td>
        <td class="yes">REQ</td><td class="yes">REQ</td><td class="yes">REQ</td>
        <td class="no">-</td><td class="no">-</td><td class="no">-</td>
        <td class="no">-</td><td class="yes">REQ</td><td class="yes">REQ</td>
      </tr>
      <tr>
        <td><strong>Labels (correct)</strong></td>
        <td class="yes">REQ</td><td class="no">-</td><td class="no">-</td>
        <td class="no">-</td><td class="no">-</td><td class="no">-</td>
        <td class="no">-</td><td class="no">-</td><td class="no">-</td>
      </tr>
      <tr>
        <td><strong>Distractor labels</strong></td>
        <td class="opt">OPT</td><td class="no">-</td><td class="no">-</td>
        <td class="opt">OPT</td><td class="no">-</td><td class="no">-</td>
        <td class="no">-</td><td class="no">-</td><td class="no">-</td>
      </tr>
      <tr>
        <td><strong>identificationPrompts</strong></td>
        <td class="no">-</td><td class="yes">REQ</td><td class="no">-</td>
        <td class="no">-</td><td class="no">-</td><td class="no">-</td>
        <td class="no">-</td><td class="no">-</td><td class="no">-</td>
      </tr>
      <tr>
        <td><strong>paths + waypoints</strong></td>
        <td class="no">-</td><td class="no">-</td><td class="yes">REQ</td>
        <td class="no">-</td><td class="no">-</td><td class="no">-</td>
        <td class="no">-</td><td class="no">-</td><td class="no">-</td>
      </tr>
      <tr>
        <td><strong>sequenceConfig.items</strong></td>
        <td class="no">-</td><td class="no">-</td><td class="no">-</td>
        <td class="yes">REQ</td><td class="no">-</td><td class="no">-</td>
        <td class="no">-</td><td class="no">-</td><td class="no">-</td>
      </tr>
      <tr>
        <td><strong>sortingConfig (items+cats)</strong></td>
        <td class="no">-</td><td class="no">-</td><td class="no">-</td>
        <td class="no">-</td><td class="yes">REQ</td><td class="no">-</td>
        <td class="no">-</td><td class="no">-</td><td class="no">-</td>
      </tr>
      <tr>
        <td><strong>memoryMatchConfig.pairs</strong></td>
        <td class="no">-</td><td class="no">-</td><td class="no">-</td>
        <td class="no">-</td><td class="no">-</td><td class="yes">REQ</td>
        <td class="no">-</td><td class="no">-</td><td class="no">-</td>
      </tr>
      <tr>
        <td><strong>branchingConfig.nodes</strong></td>
        <td class="no">-</td><td class="no">-</td><td class="no">-</td>
        <td class="no">-</td><td class="no">-</td><td class="no">-</td>
        <td class="yes">REQ</td><td class="no">-</td><td class="no">-</td>
      </tr>
      <tr>
        <td><strong>compareConfig (A+B)</strong></td>
        <td class="no">-</td><td class="no">-</td><td class="no">-</td>
        <td class="no">-</td><td class="no">-</td><td class="no">-</td>
        <td class="no">-</td><td class="yes">REQ</td><td class="no">-</td>
      </tr>
      <tr>
        <td><strong>zone.description</strong></td>
        <td class="no">-</td><td class="no">-</td><td class="no">-</td>
        <td class="no">-</td><td class="no">-</td><td class="no">-</td>
        <td class="no">-</td><td class="no">-</td><td class="yes">REQ</td>
      </tr>
      <tr>
        <td><strong>zoneGroups (hierarchy mode)</strong></td>
        <td class="opt">OPT*</td><td class="no">-</td><td class="no">-</td>
        <td class="no">-</td><td class="no">-</td><td class="no">-</td>
        <td class="no">-</td><td class="no">-</td><td class="no">-</td>
      </tr>
      <tr>
        <td><strong>temporalConstraints</strong></td>
        <td class="opt">OPT</td><td class="opt">OPT</td><td class="opt">OPT</td>
        <td class="no">-</td><td class="no">-</td><td class="no">-</td>
        <td class="no">-</td><td class="no">-</td><td class="opt">OPT</td>
      </tr>
      <tr>
        <td><strong>per-mechanic visual config</strong></td>
        <td class="opt">dragDropConfig</td><td class="opt">clickToIdentifyConfig</td><td class="opt">tracePathConfig</td>
        <td class="opt">(layout etc)</td><td class="opt">(sort_mode etc)</td><td class="opt">(variant etc)</td>
        <td class="opt">(narrative etc)</td><td class="opt">(mode etc)</td><td class="opt">(mode etc)</td>
      </tr>
      <tr>
        <td colspan="10" style="color: var(--text-muted); font-style: italic; font-size: 11px;">
          * zoneGroups is for hierarchy mode on drag_drop. Required if progressive reveal is enabled.
        </td>
      </tr>
    </table>
    <div class="legend">
      <div class="legend-item"><span class="badge badge-green">REQ</span> = Required (crash without it)</div>
      <div class="legend-item"><span class="badge badge-orange">OPT</span> = Optional (defaults apply)</div>
      <div class="legend-item"><span class="badge badge-red">-</span> = Not applicable</div>
    </div>
  </div>

  <div class="card">
    <h2>Asset Count Computation</h2>
    <p>For a game with <strong>S scenes</strong> and <strong>M mechanics per scene</strong>:</p>
    <pre>
Total assets to generate:
  Images:       S × (1 diagram + 0-1 background + 0-N overlays)
  Zone coords:  S × Z (where Z = zones per scene, from zone detection)
  Labels:       |global_labels| + |distractor_labels|
  Paths:        Σ(trace_path mechanics) × P (paths per mechanic)
  Branching:    Σ(branching mechanics) × N (nodes per tree)
  Sequences:    Σ(sequencing mechanics) × I (items per sequence)
  Pairs:        Σ(memory_match mechanics) × P (pairs per game)
  Sort items:   Σ(sorting mechanics) × (I items + C categories)
  Compare:      Σ(compare mechanics) × 2 diagrams
  Transitions:  |scene_transitions| + Σ(mode_transitions per scene)

Typical single-scene drag_drop game:
  1 image + ~8 zones + ~8 labels + ~3 distractors = ~20 data items

Typical 2-scene multi-mechanic game:
  2 images + ~16 zones + ~10 labels + 1 sequenceConfig(6 items) +
  1 tracePathConfig(5 waypoints) + ~5 distractors = ~55 data items
    </pre>
  </div>
</div>

<!-- TAB 12: VALIDATOR CHECKLIST -->
<div id="validators" class="content">
  <div class="card">
    <h2>V4 Validator Checklist</h2>
    <p>Every graph construction point needs a deterministic validator. These are the exact checks each validator must perform.</p>
  </div>

  <div class="card">
    <h3>1. Game Concept Validator</h3>
    <table>
      <tr><th>#</th><th>Check</th><th>FOL Rule</th></tr>
      <tr><td>1.1</td><td>Title non-empty</td><td>R: <code>title ≠ ""</code></td></tr>
      <tr><td>1.2</td><td>At least 1 scene</td><td>R: <code>|scenes| ≥ 1</code></td></tr>
      <tr><td>1.3</td><td>Sequential scene numbers</td><td>R1.1</td></tr>
      <tr><td>1.4</td><td>At least 3 zone labels</td><td>R: <code>|zone_labels| ≥ 3</code></td></tr>
      <tr><td>1.5</td><td>Each scene has ≥ 1 mechanic</td><td>R1.5</td></tr>
      <tr><td>1.6</td><td>Scene zone_labels ⊆ global</td><td>R1.6</td></tr>
      <tr><td>1.7</td><td>Mechanic types are valid</td><td>R: <code>type ∈ VALID_MECHANIC_TYPES</code></td></tr>
      <tr><td>1.8</td><td>Hierarchy parents in labels</td><td>R4.5</td></tr>
      <tr><td>1.9</td><td>Hierarchy children in labels</td><td>R4.6</td></tr>
      <tr><td>1.10</td><td>Scene transitions reference valid scenes</td><td>R1.2</td></tr>
    </table>
  </div>

  <div class="card">
    <h3>2. Scene Design Validator</h3>
    <table>
      <tr><th>#</th><th>Check</th><th>FOL Rule</th></tr>
      <tr><td>2.1</td><td>Zone coordinates present (non-null)</td><td>R: <code>∀z: z.coordinates ≠ null</code></td></tr>
      <tr><td>2.2</td><td>Coordinates in 0-100 range</td><td>R: <code>0 ≤ x,y ≤ 100</code></td></tr>
      <tr><td>2.3</td><td>No overlapping zones (within tolerance)</td><td>Optional check</td></tr>
      <tr><td>2.4</td><td>Mechanic configs present for type</td><td>See per-mechanic checks</td></tr>
      <tr><td>2.5</td><td>trace_path: waypoints reference valid zone labels</td><td>R5.1</td></tr>
      <tr><td>2.6</td><td>trace_path: ≥ 2 waypoints</td><td>R5.3</td></tr>
      <tr><td>2.7</td><td>click_to_identify: prompts present</td><td>Frontend check</td></tr>
    </table>
  </div>

  <div class="card">
    <h3>3. Content Validator (per mechanic type)</h3>
    <table>
      <tr><th>#</th><th>Check</th><th>Mechanic</th></tr>
      <tr><td>3.1</td><td><code>items.length ≥ 3 ∧ correctOrder references valid IDs</code></td><td>sequencing</td></tr>
      <tr><td>3.2</td><td><code>categories.length ≥ 2 ∧ items reference valid category IDs</code></td><td>sorting</td></tr>
      <tr><td>3.3</td><td><code>pairs.length ≥ 3 ∧ each pair has term + definition</code></td><td>memory_match</td></tr>
      <tr><td>3.4</td><td><code>nodes.length ≥ 2 ∧ startNodeId valid ∧ end node exists ∧ no orphans</code></td><td>branching</td></tr>
      <tr><td>3.5</td><td><code>expectedCategories ≥ 1 ∧ diagramA + diagramB present</code></td><td>compare</td></tr>
      <tr><td>3.6</td><td><code>zones have descriptions</code></td><td>description_matching</td></tr>
    </table>
  </div>

  <div class="card">
    <h3>4. Blueprint Validator (final gate before frontend)</h3>
    <table>
      <tr><th>#</th><th>Check</th><th>Severity</th></tr>
      <tr><td>4.1</td><td><code>templateType = "INTERACTIVE_DIAGRAM"</code></td><td>FATAL</td></tr>
      <tr><td>4.2</td><td>All zone IDs unique</td><td>FATAL</td></tr>
      <tr><td>4.3</td><td>All label IDs unique</td><td>FATAL</td></tr>
      <tr><td>4.4</td><td><code>label.correctZoneId</code> references existing zone</td><td>FATAL</td></tr>
      <tr><td>4.5</td><td>Mode transitions reference valid mechanic types</td><td>FATAL</td></tr>
      <tr><td>4.6</td><td>Branching node graph is connected</td><td>WARNING</td></tr>
      <tr><td>4.7</td><td>Zone coordinates are numbers (not strings)</td><td>FATAL</td></tr>
      <tr><td>4.8</td><td>Score totals are consistent</td><td>WARNING</td></tr>
      <tr><td>4.9</td><td>Per-mechanic config field present for active mechanics</td><td>FATAL</td></tr>
      <tr><td>4.10</td><td>Hierarchy tree has no cycles</td><td>FATAL</td></tr>
    </table>
  </div>
</div>

<script>
function showTab(id) {
  document.querySelectorAll('.content').forEach(c => c.classList.remove('active'));
  document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
  document.getElementById(id).classList.add('active');
  event.target.classList.add('active');
  // Re-render mermaid for the newly visible tab
  setTimeout(() => {
    const el = document.getElementById(id);
    const unrendered = el.querySelectorAll('.mermaid:not([data-processed])');
    if (unrendered.length > 0) {
      mermaid.run({ nodes: unrendered });
    }
  }, 50);
}

mermaid.initialize({
  startOnLoad: true,
  theme: 'dark',
  themeVariables: {
    primaryColor: '#1f6feb',
    primaryTextColor: '#e6edf3',
    primaryBorderColor: '#30363d',
    lineColor: '#8b949e',
    secondaryColor: '#161b22',
    tertiaryColor: '#0d1117',
    background: '#0d1117',
    mainBkg: '#161b22',
    nodeBorder: '#30363d',
    clusterBkg: '#0d1117',
    clusterBorder: '#30363d',
    titleColor: '#e6edf3',
    edgeLabelBackground: '#161b22',
  },
  flowchart: { curve: 'basis', padding: 15 },
});
</script>
</body>
</html>
