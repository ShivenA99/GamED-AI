<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>V4 Pipeline Architecture — GamED.AI</title>
<script src="https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.min.js"></script>
<style>
  :root {
    --bg: #0d1117;
    --surface: #161b22;
    --border: #30363d;
    --text: #e6edf3;
    --text-muted: #8b949e;
    --accent: #58a6ff;
    --green: #3fb950;
    --orange: #d29922;
    --red: #f85149;
    --purple: #bc8cff;
    --pink: #f778ba;
  }
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
    background: var(--bg);
    color: var(--text);
    line-height: 1.6;
  }
  .header {
    background: linear-gradient(135deg, #1a1f35 0%, #0d1117 100%);
    border-bottom: 1px solid var(--border);
    padding: 2rem 3rem;
  }
  .header h1 { font-size: 2rem; font-weight: 700; }
  .header p { color: var(--text-muted); margin-top: 0.5rem; }
  .nav {
    position: sticky; top: 0; z-index: 100;
    background: var(--surface);
    border-bottom: 1px solid var(--border);
    display: flex; flex-wrap: wrap;
    padding: 0 1rem;
  }
  .nav button {
    background: none; border: none; color: var(--text-muted);
    padding: 0.75rem 1rem; cursor: pointer; font-size: 0.85rem;
    border-bottom: 2px solid transparent; transition: all 0.2s;
    white-space: nowrap;
  }
  .nav button:hover { color: var(--text); }
  .nav button.active { color: var(--accent); border-bottom-color: var(--accent); }
  .section {
    display: none; padding: 2rem 3rem; max-width: 1400px; margin: 0 auto;
  }
  .section.active { display: block; }
  .section h2 {
    font-size: 1.5rem; margin-bottom: 1rem;
    padding-bottom: 0.5rem; border-bottom: 1px solid var(--border);
  }
  .section h3 { font-size: 1.15rem; margin: 1.5rem 0 0.75rem; color: var(--accent); }
  .section h4 { font-size: 1rem; margin: 1rem 0 0.5rem; color: var(--purple); }
  .diagram-container {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 1.5rem;
    margin: 1rem 0 2rem;
    overflow-x: auto;
  }
  .diagram-container .mermaid { text-align: center; }
  .info-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 1rem; margin: 1rem 0;
  }
  .info-card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 1.25rem;
  }
  .info-card h4 { margin: 0 0 0.5rem; color: var(--green); font-size: 0.95rem; }
  .info-card p { color: var(--text-muted); font-size: 0.85rem; }
  .info-card.warn { border-left: 3px solid var(--orange); }
  .info-card.good { border-left: 3px solid var(--green); }
  .info-card.bad { border-left: 3px solid var(--red); }
  .info-card.neutral { border-left: 3px solid var(--accent); }
  table {
    width: 100%; border-collapse: collapse;
    margin: 1rem 0; font-size: 0.85rem;
  }
  th, td {
    text-align: left; padding: 0.5rem 0.75rem;
    border: 1px solid var(--border);
  }
  th { background: var(--surface); color: var(--accent); font-weight: 600; }
  td { color: var(--text-muted); }
  code {
    background: rgba(110,118,129,0.15);
    padding: 0.15em 0.4em;
    border-radius: 4px;
    font-size: 0.85em;
    color: var(--orange);
  }
  .tag {
    display: inline-block;
    padding: 0.15em 0.5em;
    border-radius: 12px;
    font-size: 0.75rem;
    font-weight: 600;
  }
  .tag-llm { background: rgba(188,140,255,0.2); color: var(--purple); }
  .tag-det { background: rgba(63,185,80,0.2); color: var(--green); }
  .tag-tool { background: rgba(210,153,34,0.2); color: var(--orange); }
  .tag-router { background: rgba(88,166,255,0.2); color: var(--accent); }
  .legend {
    display: flex; gap: 1.5rem; flex-wrap: wrap;
    margin: 1rem 0; font-size: 0.8rem;
  }
  .legend span { display: flex; align-items: center; gap: 0.4rem; }
  .react-comparison {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 1.5rem; margin: 1rem 0;
  }
  @media (max-width: 800px) {
    .react-comparison { grid-template-columns: 1fr; }
    .section { padding: 1rem; }
    .header { padding: 1.5rem; }
  }
</style>
</head>
<body>

<div class="header">
  <h1>V4 Pipeline Architecture</h1>
  <p>GamED.AI — 3-Stage Creative Cascade with Destructured Validation | 22 nodes, 5 Send routers, 10 mechanic types</p>
</div>

<div class="nav" id="nav">
  <button class="active" data-tab="overview">Full Pipeline</button>
  <button data-tab="dataflow">Data Flow</button>
  <button data-tab="context">Context Pulling</button>
  <button data-tab="react">ReAct Analysis</button>
  <button data-tab="retry">Retry Loops</button>
  <button data-tab="dragdrop">Drag &amp; Drop</button>
  <button data-tab="clickid">Click to Identify</button>
  <button data-tab="tracepath">Trace Path</button>
  <button data-tab="sequencing">Sequencing</button>
  <button data-tab="sorting">Sorting</button>
  <button data-tab="memory">Memory Match</button>
  <button data-tab="branching">Branching</button>
  <button data-tab="compare">Compare</button>
  <button data-tab="description">Description Match</button>
  <button data-tab="hierarchical">Hierarchical</button>
  <button data-tab="assembly">Blueprint Assembly</button>
</div>

<!-- ═══════════════════════════════════════════════════ -->
<!-- TAB: Full Pipeline Overview -->
<!-- ═══════════════════════════════════════════════════ -->
<div class="section active" id="tab-overview">
  <h2>Full V4 Pipeline Graph</h2>
  <div class="legend">
    <span><span class="tag tag-llm">LLM</span> LLM call</span>
    <span><span class="tag tag-det">DET</span> Deterministic</span>
    <span><span class="tag tag-tool">TOOL</span> Tool chain</span>
    <span><span class="tag tag-router">ROUTER</span> Send fan-out</span>
  </div>
  <div class="diagram-container">
    <pre class="mermaid">
graph TD
    START((START))

    subgraph Phase0["Phase 0: Understanding"]
        direction LR
        IA["v4_input_analyzer<br/><small>LLM: gemini-flash</small>"]
        DK["v4_dk_retriever<br/><small>LLM: gemini-flash</small>"]
        M0["v4_merge_phase0<br/><small>deterministic</small>"]
    end

    subgraph Phase1a["Phase 1a: Game Concept"]
        GCD["v4_game_concept_designer<br/><small>LLM: gemini-pro</small>"]
        CV["v4_concept_validator<br/><small>deterministic</small>"]
    end

    subgraph Phase1b["Phase 1b: Scene Design (parallel per scene)"]
        R1{{"concept_router<br/><small>Send per scene</small>"}}
        SD["v4_scene_designer<br/><small>LLM: gemini-pro × N</small>"]
        SDM["v4_scene_design_merge<br/><small>deterministic</small>"]
        R2{{"retry_router"}}
        GB["v4_graph_builder<br/><small>deterministic</small>"]
    end

    subgraph Phase2a["Phase 2a: Content Build (parallel per mechanic)"]
        R3{{"content_dispatch_router<br/><small>Send per mechanic</small>"}}
        CG["v4_content_generator<br/><small>LLM × M mechanics</small>"]
        CM["v4_content_merge<br/><small>deterministic</small>"]
        R4{{"retry_router"}}
    end

    subgraph Phase2b["Phase 2b: Interaction Design (parallel per scene)"]
        R5{{"interaction_dispatch<br/><small>Send per scene</small>"}}
        ID["v4_interaction_designer<br/><small>LLM: gemini-flash × N</small>"]
        IM["v4_interaction_merge<br/><small>deterministic</small>"]
        R6{{"retry_router"}}
    end

    subgraph Phase3a["Phase 3a: Asset Art Direction (parallel per scene)"]
        ANA["v4_asset_needs_analyzer<br/><small>deterministic</small>"]
        R7{{"art_direction_dispatch<br/><small>Send per scene</small>"}}
        AAD["v4_asset_art_director<br/><small>LLM: gemini-flash × N</small>"]
        ADM["v4_art_direction_merge<br/><small>deterministic</small>"]
        R8{{"retry_router"}}
    end

    subgraph Phase3b["Phase 3b: Asset Chains (parallel per asset)"]
        R9{{"asset_chain_dispatch<br/><small>Send per asset</small>"}}
        ACR["v4_asset_chain_runner<br/><small>tool chains × K</small>"]
        AM["v4_asset_merge<br/><small>deterministic</small>"]
    end

    subgraph Phase4["Phase 4: Assembly"]
        BA["v4_blueprint_assembler<br/><small>deterministic</small>"]
        BV["v4_blueprint_validator<br/><small>deterministic</small>"]
    end

    ENDNODE((END))

    START --> IA & DK
    IA --> M0
    DK --> M0
    M0 --> GCD
    GCD --> CV
    CV --> R1
    R1 -->|"Send × N scenes"| SD
    CV -.->|"retry"| GCD
    SD --> SDM
    SDM --> R2
    R2 -->|"Send failed"| SD
    R2 -->|"proceed"| GB
    GB --> R3
    R3 -->|"Send × M mechs"| CG
    CG --> CM
    CM --> R4
    R4 -->|"Send failed"| CG
    R4 -->|"proceed"| R5
    R5 -->|"Send × N scenes"| ID
    ID --> IM
    IM --> R6
    R6 -->|"Send failed"| ID
    R6 -->|"proceed"| ANA
    ANA --> R7
    R7 -->|"Send × N scenes"| AAD
    AAD --> ADM
    ADM --> R8
    R8 -->|"Send failed"| AAD
    R8 -->|"proceed"| R9
    R9 -->|"Send × K assets"| ACR
    ACR --> AM
    AM --> BA
    BA --> BV
    BV --> ENDNODE

    style START fill:#58a6ff,stroke:none,color:#000
    style ENDNODE fill:#3fb950,stroke:none,color:#000
    style R1 fill:#1f2937,stroke:#58a6ff,color:#58a6ff
    style R2 fill:#1f2937,stroke:#58a6ff,color:#58a6ff
    style R3 fill:#1f2937,stroke:#58a6ff,color:#58a6ff
    style R4 fill:#1f2937,stroke:#58a6ff,color:#58a6ff
    style R5 fill:#1f2937,stroke:#58a6ff,color:#58a6ff
    style R6 fill:#1f2937,stroke:#58a6ff,color:#58a6ff
    style R7 fill:#1f2937,stroke:#58a6ff,color:#58a6ff
    style R8 fill:#1f2937,stroke:#58a6ff,color:#58a6ff
    style R9 fill:#1f2937,stroke:#58a6ff,color:#58a6ff
    style GCD fill:#2d1b4e,stroke:#bc8cff,color:#e6edf3
    style SD fill:#2d1b4e,stroke:#bc8cff,color:#e6edf3
    style CG fill:#2d1b4e,stroke:#bc8cff,color:#e6edf3
    style ID fill:#2d1b4e,stroke:#bc8cff,color:#e6edf3
    style AAD fill:#2d1b4e,stroke:#bc8cff,color:#e6edf3
    style IA fill:#2d1b4e,stroke:#bc8cff,color:#e6edf3
    style DK fill:#2d1b4e,stroke:#bc8cff,color:#e6edf3
    style GB fill:#1b3d2e,stroke:#3fb950,color:#e6edf3
    style ANA fill:#1b3d2e,stroke:#3fb950,color:#e6edf3
    style BA fill:#1b3d2e,stroke:#3fb950,color:#e6edf3
    style BV fill:#1b3d2e,stroke:#3fb950,color:#e6edf3
    style M0 fill:#1b3d2e,stroke:#3fb950,color:#e6edf3
    style SDM fill:#1b3d2e,stroke:#3fb950,color:#e6edf3
    style CM fill:#1b3d2e,stroke:#3fb950,color:#e6edf3
    style IM fill:#1b3d2e,stroke:#3fb950,color:#e6edf3
    style ADM fill:#1b3d2e,stroke:#3fb950,color:#e6edf3
    style AM fill:#1b3d2e,stroke:#3fb950,color:#e6edf3
    style ACR fill:#3d2e1b,stroke:#d29922,color:#e6edf3
    style CV fill:#1b3d2e,stroke:#3fb950,color:#e6edf3
    </pre>
  </div>

  <h3>Node Summary</h3>
  <table>
    <tr><th>Phase</th><th>Nodes</th><th>Type</th><th>Parallelism</th></tr>
    <tr><td>0: Understanding</td><td>input_analyzer, dk_retriever, merge_phase0</td><td>2 LLM + 1 merge</td><td>2 parallel from START</td></tr>
    <tr><td>1a: Concept</td><td>game_concept_designer, concept_validator</td><td>1 LLM + 1 validator</td><td>Sequential</td></tr>
    <tr><td>1b: Scene Design</td><td>scene_designer, scene_design_merge, graph_builder</td><td>1 LLM×N + 2 det</td><td>N scenes parallel (Send)</td></tr>
    <tr><td>2a: Content</td><td>content_generator, content_merge</td><td>1 LLM×M + 1 merge</td><td>M mechanics parallel (Send)</td></tr>
    <tr><td>2b: Interaction</td><td>interaction_designer, interaction_merge</td><td>1 LLM×N + 1 merge</td><td>N scenes parallel (Send)</td></tr>
    <tr><td>3a: Art Direction</td><td>asset_needs_analyzer, asset_art_director, art_direction_merge</td><td>1 det + 1 LLM×N + 1 merge</td><td>N scenes parallel (Send)</td></tr>
    <tr><td>3b: Asset Chains</td><td>asset_chain_runner, asset_merge</td><td>1 tool×K + 1 merge</td><td>K assets parallel (Send)</td></tr>
    <tr><td>4: Assembly</td><td>blueprint_assembler, blueprint_validator</td><td>2 deterministic</td><td>Sequential</td></tr>
  </table>
</div>

<!-- ═══════════════════════════════════════════════════ -->
<!-- TAB: Data Flow -->
<!-- ═══════════════════════════════════════════════════ -->
<div class="section" id="tab-dataflow">
  <h2>End-to-End Data Flow</h2>
  <p>Every piece of data traced from creation to final consumption. Arrows show what schemas flow between stages.</p>

  <div class="diagram-container">
    <pre class="mermaid">
graph LR
    subgraph Input["User Input"]
        Q["question_text<br/>question_options"]
    end

    subgraph P0["Phase 0 Outputs"]
        PC["PedagogicalContext<br/><small>blooms, objectives, misconceptions</small>"]
        CS["ContentStructure<br/><small>type, visual_needs, has_*</small>"]
        DKO["DomainKnowledge<br/><small>labels, descriptions, sequences</small>"]
        CL["canonical_labels<br/><small>List[str]</small>"]
    end

    subgraph P1a["Phase 1a Output"]
        GC["GameConcept<br/><small>title, scenes[], mechanics[], narrative</small>"]
    end

    subgraph P1b["Phase 1b Output"]
        SCD["SceneCreativeDesign × N<br/><small>visual_concept, image_spec,<br/>mechanic_designs[]</small>"]
    end

    subgraph GB_OUT["Graph Builder Output"]
        GP["GamePlan<br/><small>scenes: ScenePlan[]<br/>each with MechanicPlan[]<br/>+ mechanic_connections</small>"]
    end

    subgraph P2a["Phase 2a Output"]
        MC["MechanicContent × M<br/><small>per-type content data<br/>+ visual config fields</small>"]
    end

    subgraph P2b["Phase 2b Output"]
        SC["SceneContent × N<br/><small>zone_specs, scoring[],<br/>feedback[], mode_transitions</small>"]
    end

    subgraph P3a_out["Phase 3a Output"]
        AN["AssetNeeds × N<br/><small>diagrams, item_images,<br/>color_palettes</small>"]
        ADM_OUT["ArtDirectedManifest × N<br/><small>search_queries, style_prompts,<br/>color_palettes</small>"]
    end

    subgraph P3b_out["Phase 3b Output"]
        SA["SceneAssets × N<br/><small>image_urls, zones[],<br/>item_images[], palettes</small>"]
    end

    subgraph P4["Phase 4 Output"]
        BP["Blueprint JSON<br/><small>Frontend-ready contract</small>"]
    end

    Q --> PC & CS & DKO & CL
    PC --> GC
    CS --> GC
    DKO --> GC
    CL --> GC
    GC --> SCD
    DKO --> SCD
    PC --> SCD
    GC --> GP
    SCD --> GP
    GP --> MC
    DKO --> MC
    GP --> SC
    MC --> SC
    PC --> SC
    GP --> AN
    SC --> AN
    AN --> ADM_OUT
    SCD --> ADM_OUT
    SC --> ADM_OUT
    ADM_OUT --> SA
    GP --> BP
    SC --> BP
    SA --> BP

    style Q fill:#58a6ff,stroke:none,color:#000
    style BP fill:#3fb950,stroke:none,color:#000
    </pre>
  </div>

  <h3>State Field Ownership</h3>
  <table>
    <tr><th>State Field</th><th>Written By</th><th>Read By</th><th>Type</th></tr>
    <tr><td><code>pedagogical_context</code></td><td>input_analyzer</td><td>concept_designer, scene_designer, interaction_designer, art_director</td><td>Dict</td></tr>
    <tr><td><code>content_structure</code></td><td>input_analyzer</td><td>concept_designer</td><td>ContentStructure</td></tr>
    <tr><td><code>domain_knowledge</code></td><td>dk_retriever</td><td>concept_designer, scene_designer, content_generator, interaction_designer</td><td>Dict</td></tr>
    <tr><td><code>canonical_labels</code></td><td>dk_retriever</td><td>concept_designer</td><td>List[str]</td></tr>
    <tr><td><code>game_concept</code></td><td>game_concept_designer</td><td>concept_validator, scene_designer (via Send), graph_builder</td><td>GameConcept</td></tr>
    <tr><td><code>scene_creative_designs</code></td><td>scene_designer (×N)</td><td>scene_design_merge, graph_builder</td><td>{idx: SceneCreativeDesign}</td></tr>
    <tr><td><code>game_plan</code></td><td>graph_builder</td><td>content_generator, interaction_designer, asset_needs_analyzer, art_director, blueprint_assembler</td><td>GamePlan</td></tr>
    <tr><td><code>scene_contents</code></td><td>content_merge + interaction_merge</td><td>asset_needs_analyzer, art_director, blueprint_assembler</td><td>{scene_id: SceneContent}</td></tr>
    <tr><td><code>asset_needs</code></td><td>asset_needs_analyzer</td><td>art_direction_dispatch_router</td><td>{scene_id: AssetNeeds}</td></tr>
    <tr><td><code>art_directed_manifests</code></td><td>asset_art_director (×N)</td><td>asset_chain_dispatch_router</td><td>{scene_id: ArtDirectedManifest}</td></tr>
    <tr><td><code>scene_assets</code></td><td>asset_merge</td><td>blueprint_assembler</td><td>{scene_id: SceneAssets}</td></tr>
    <tr><td><code>blueprint</code></td><td>blueprint_assembler</td><td>blueprint_validator, routes/generate.py</td><td>Dict (frontend JSON)</td></tr>
    <tr><td><code>failed_scene_ids</code></td><td>scene_design_merge</td><td>retry_router</td><td>Annotated[List, add]</td></tr>
    <tr><td><code>failed_mechanic_ids</code></td><td>content_merge</td><td>retry_router</td><td>Annotated[List, add]</td></tr>
  </table>
</div>

<!-- ═══════════════════════════════════════════════════ -->
<!-- TAB: Context Pulling -->
<!-- ═══════════════════════════════════════════════════ -->
<div class="section" id="tab-context">
  <h2>Context Pulling — What Each Agent Receives</h2>
  <p>Each LLM agent receives data through <strong>Send() payloads</strong> (explicit) or <strong>shared state</strong> reads. No ReAct tool-calling — all context is pre-assembled.</p>

  <div class="diagram-container">
    <pre class="mermaid">
graph TB
    subgraph SharedState["Shared State (readable by all)"]
        direction LR
        S_PC["pedagogical_context"]
        S_DK["domain_knowledge"]
        S_CL["canonical_labels"]
        S_CS["content_structure"]
        S_GC["game_concept"]
        S_GP["game_plan"]
        S_SC["scene_contents"]
        S_AN["asset_needs"]
    end

    subgraph GCD_CTX["game_concept_designer receives"]
        direction TB
        GCD1["question_text ← state"]
        GCD2["pedagogical_context ← state"]
        GCD3["domain_knowledge summary ← state"]
        GCD4["canonical_labels ← state"]
        GCD5["capability_spec ← static import"]
        GCD6["validation_feedback ← state (retry only)"]
    end

    subgraph SD_CTX["scene_designer receives (via Send)"]
        direction TB
        SD1["scene_concept ← Send payload"]
        SD2["narrative_theme ← Send payload"]
        SD3["domain_knowledge ← Send payload"]
        SD4["pedagogical_context ← Send payload"]
        SD5["attempt + validation_feedback ← Send"]
    end

    subgraph CG_CTX["content_generator receives (via Send)"]
        direction TB
        CG1["mechanic_plan ← Send payload"]
        CG2["scene_context ← Send payload<br/><small>(built by build_scene_context helper)</small>"]
        CG3["domain_knowledge ← Send payload"]
        CG4["attempt + feedback ← Send (retry)"]
    end

    subgraph SC_BUILD["scene_context (built by helper)"]
        direction TB
        SCB1["zone_labels + DK descriptions"]
        SCB2["relevant_dk_data (seq, compare, etc.)"]
        SCB3["other_mechanics list"]
        SCB4["shared_terminology"]
        SCB5["creative_vision from ScenePlan"]
    end

    subgraph ID_CTX["interaction_designer receives (via Send)"]
        direction TB
        ID1["scene_plan ← Send payload"]
        ID2["mechanic_contents ← Send payload"]
        ID3["mechanic_plans ← Send payload"]
        ID4["pedagogical_context ← Send payload"]
        ID5["domain_knowledge ← Send payload"]
    end

    subgraph AAD_CTX["asset_art_director receives (via Send)"]
        direction TB
        AAD1["asset_needs ← Send payload"]
        AAD2["creative_design ← Send payload<br/><small>(SceneCreativeDesign from ScenePlan)</small>"]
        AAD3["scene_content ← Send payload"]
        AAD4["pedagogical_context ← Send payload"]
    end

    S_DK -.-> CG_CTX
    S_DK -.-> SD_CTX
    S_GP -.-> CG_CTX
    S_GP -.-> ID_CTX

    style SharedState fill:#1b2838,stroke:#30363d
    style GCD_CTX fill:#1f1b2e,stroke:#bc8cff
    style SD_CTX fill:#1f1b2e,stroke:#bc8cff
    style CG_CTX fill:#1f1b2e,stroke:#bc8cff
    style SC_BUILD fill:#1b2e1f,stroke:#3fb950
    style ID_CTX fill:#1f1b2e,stroke:#bc8cff
    style AAD_CTX fill:#1f1b2e,stroke:#bc8cff
    </pre>
  </div>

  <h3>Context Pulling Strategy</h3>
  <div class="info-grid">
    <div class="info-card good">
      <h4>Explicit Send Payloads</h4>
      <p>All parallel workers (scene_designer, content_generator, interaction_designer, art_director) receive ALL needed data via Send() payload. No implicit state reads needed inside workers.</p>
    </div>
    <div class="info-card good">
      <h4>Pre-built Scene Context</h4>
      <p><code>build_scene_context()</code> helper runs inside the content_dispatch_router BEFORE sending. Each content_generator gets a fully assembled context dict — no redundant DK lookups.</p>
    </div>
    <div class="info-card good">
      <h4>Creative Design Forwarding</h4>
      <p>SceneCreativeDesign is embedded in GamePlan.scenes[].creative_design. Art direction router extracts and sends it explicitly — no fragile state lookups.</p>
    </div>
    <div class="info-card neutral">
      <h4>Validation Feedback Injection</h4>
      <p>On retry, routers pull validation feedback from state and inject into Send payload. Agents don't need to know about retry — they just see extra context in their input.</p>
    </div>
  </div>

  <h3>Data Transformations</h3>
  <div class="diagram-container">
    <pre class="mermaid">
graph LR
    subgraph Transform1["Graph Builder (deterministic)"]
        T1A["GameConcept"] --> T1B["GamePlan"]
        T1C["SceneCreativeDesign[]"] --> T1B
        T1D["<small>Assigns mechanic_ids<br/>Computes scores<br/>Builds connections<br/>Embeds creative_design</small>"]
    end

    subgraph Transform2["Content Merge (deterministic)"]
        T2A["MechanicContent[]<br/>(from parallel generators)"] --> T2B["Partial SceneContent<br/>(mechanic_contents only)"]
    end

    subgraph Transform3["Interaction Merge (deterministic)"]
        T3A["Partial SceneContent"] --> T3B["Complete SceneContent<br/>(+ zone_specs, scoring,<br/>feedback, transitions)"]
        T3C["InteractionDesigner output"] --> T3B
    end

    subgraph Transform4["Blueprint Assembler (deterministic)"]
        T4A["GamePlan"] --> T4D["Blueprint JSON"]
        T4B["SceneContent[]"] --> T4D
        T4C["SceneAssets[]"] --> T4D
        T4E["<small>zone_label → zone_id mapping<br/>coordinate conversion<br/>config merge per mechanic<br/>camelCase conversion<br/>image URL injection</small>"]
    end

    style Transform1 fill:#1b2e1f,stroke:#3fb950
    style Transform2 fill:#1b2e1f,stroke:#3fb950
    style Transform3 fill:#1b2e1f,stroke:#3fb950
    style Transform4 fill:#1b2e1f,stroke:#3fb950
    </pre>
  </div>
</div>

<!-- ═══════════════════════════════════════════════════ -->
<!-- TAB: ReAct Analysis -->
<!-- ═══════════════════════════════════════════════════ -->
<div class="section" id="tab-react">
  <h2>ReAct Agent Analysis — Where Would It Help?</h2>
  <p>V3 used ReAct for all creative agents (5 tools per agent). V4 deliberately avoids it. Here's the analysis of where ReAct could add value vs. where it hurts.</p>

  <h3>V3 ReAct Problems (Why V4 Avoids It)</h3>
  <div class="info-grid">
    <div class="info-card bad">
      <h4>Gemini Flash Stops Early</h4>
      <p>Gemini-2.5-flash stops at 3 iterations without calling submit tools. Only gemini-pro follows multi-tool workflows — 3x cost.</p>
    </div>
    <div class="info-card bad">
      <h4>Performance ≠ Reasoning</h4>
      <p>Research (arXiv:2405.13966) shows ReAct performance is driven by exemplar-query similarity, NOT reasoning traces. Structured output + validation achieves same quality.</p>
    </div>
    <div class="info-card bad">
      <h4>15K Token Retries</h4>
      <p>V3 ReAct agents carry full conversation history in retries. V4's scoped retries cost 3-5K tokens per retry.</p>
    </div>
    <div class="info-card bad">
      <h4>Unpredictable Latency</h4>
      <p>ReAct agents take 2-8 iterations unpredictably. V4 single-call agents have deterministic latency bounds.</p>
    </div>
  </div>

  <h3>Per-Agent ReAct Evaluation</h3>
  <table>
    <tr><th>Agent</th><th>V4 Approach</th><th>ReAct Benefit?</th><th>Verdict</th></tr>
    <tr>
      <td><code>game_concept_designer</code></td>
      <td>Single structured call → GameConcept</td>
      <td>Low. Output is holistic concept, not iterative exploration.</td>
      <td style="color:var(--green)">Keep single-call</td>
    </tr>
    <tr>
      <td><code>scene_designer</code></td>
      <td>Single structured call → SceneCreativeDesign</td>
      <td>Low. Creative direction is one coherent vision, not multi-step.</td>
      <td style="color:var(--green)">Keep single-call</td>
    </tr>
    <tr>
      <td><code>content_generator</code></td>
      <td>Single call per mechanic → MechanicContent</td>
      <td>Medium for branching (graph construction is complex). Low for others.</td>
      <td style="color:var(--orange)">Consider for branching only</td>
    </tr>
    <tr>
      <td><code>interaction_designer</code></td>
      <td>Single call per scene → scoring + feedback</td>
      <td>Low. Scoring is arithmetic-constrained, not exploratory.</td>
      <td style="color:var(--green)">Keep single-call</td>
    </tr>
    <tr>
      <td><code>asset_art_director</code></td>
      <td>Single call → ArtDirectedManifest</td>
      <td>Medium. Could verify image search availability before committing queries.</td>
      <td style="color:var(--orange)">Consider for V4.1</td>
    </tr>
    <tr>
      <td><code>dk_retriever</code></td>
      <td>Iterative web search (reuse V3 loop)</td>
      <td>Already iterative. ReAct adds overhead without benefit.</td>
      <td style="color:var(--green)">Keep iterative loop</td>
    </tr>
    <tr>
      <td><code>zone_matcher</code></td>
      <td>Deterministic fuzzy match + optional LLM fallback</td>
      <td>Medium. LLM disambiguation for ambiguous labels could use ReAct.</td>
      <td style="color:var(--green)">Keep deterministic + LLM fallback</td>
    </tr>
  </table>

  <h3>ReAct vs. Single-Call: Side-by-Side</h3>
  <div class="react-comparison">
    <div class="info-card bad">
      <h4>V3 ReAct: Branching Content</h4>
      <p>
        <strong>5 tools</strong>: analyze_content, generate_mechanic_content, enrich_mechanic_content, check_capabilities, submit_interaction_spec<br/><br/>
        <strong>Typical flow</strong>: analyze → generate → check → enrich → submit<br/>
        <strong>Iterations</strong>: 5-8<br/>
        <strong>Tokens</strong>: ~12K<br/>
        <strong>Failure mode</strong>: Gemini-flash stops at iteration 3 without calling submit
      </p>
    </div>
    <div class="info-card good">
      <h4>V4 Single-Call: Branching Content</h4>
      <p>
        <strong>1 call</strong>: content_generator with rich prompt<br/><br/>
        <strong>Prompt includes</strong>: MechanicPlan + scene_context + DK + creative_design<br/>
        <strong>Iterations</strong>: 1 (+ 1-2 retries if validation fails)<br/>
        <strong>Tokens</strong>: ~3K (+ 3K per retry)<br/>
        <strong>Failure mode</strong>: Validator catches issues, scoped retry
      </p>
    </div>
  </div>

  <h3>Where ReAct WOULD Help (V4.1 Candidates)</h3>
  <div class="diagram-container">
    <pre class="mermaid">
graph TB
    subgraph ReActCandidate1["Candidate: Adaptive Art Director"]
        direction TB
        AAD1["Receive AssetNeeds"]
        AAD2["Tool: search_image_availability(query)"]
        AAD3["Tool: check_style_compatibility(ref_image, style)"]
        AAD4["Tool: generate_color_palette(theme, constraints)"]
        AAD5["Tool: submit_manifest(ArtDirectedManifest)"]
        AAD1 --> AAD2 --> AAD3 --> AAD4 --> AAD5
        AAD2 -.->|"no results"| AAD2
        AAD3 -.->|"incompatible"| AAD2
    end

    subgraph ReActCandidate2["Candidate: Branching Graph Builder"]
        direction TB
        BG1["Receive MechanicPlan (branching)"]
        BG2["Tool: create_node(question, options)"]
        BG3["Tool: add_connection(from, to, trigger)"]
        BG4["Tool: validate_graph_connectivity()"]
        BG5["Tool: submit_branching_content()"]
        BG1 --> BG2 --> BG3 --> BG4
        BG4 -.->|"disconnected"| BG2
        BG4 -->|"valid"| BG5
    end

    style ReActCandidate1 fill:#2e1f1b,stroke:#d29922
    style ReActCandidate2 fill:#2e1f1b,stroke:#d29922
    </pre>
  </div>

  <div class="info-grid">
    <div class="info-card warn">
      <h4>Recommendation: Ship V4 Without ReAct</h4>
      <p>Single-call + structured output + deterministic validation is the right default. ReAct adds 2-5x latency and unpredictability. If branching content quality is insufficient after V4 launch, add ReAct to <strong>only</strong> the branching content_generator as a V4.1 enhancement.</p>
    </div>
    <div class="info-card warn">
      <h4>ReAct Prerequisite: Model Support</h4>
      <p>ReAct requires a model that reliably follows multi-tool workflows. Only <code>gemini-2.5-pro</code> does this. At 3x cost per call, ReAct is only viable for the 1-2 most complex agents. NOT for all 7 LLM agents.</p>
    </div>
  </div>
</div>

<!-- ═══════════════════════════════════════════════════ -->
<!-- TAB: Retry Loops -->
<!-- ═══════════════════════════════════════════════════ -->
<div class="section" id="tab-retry">
  <h2>Retry Loop Architecture</h2>

  <div class="diagram-container">
    <pre class="mermaid">
graph TB
    subgraph ConceptRetry["Phase 1a: Concept Retry (static edge)"]
        direction LR
        CR1["game_concept_designer"] --> CR2["concept_validator"]
        CR2 -->|"failed + retries < 2"| CR1
        CR2 -->|"passed"| CR3["Send to scene_designers"]
        CR4["<small>Scope: 1 agent, ~4K tokens<br/>Max retries: 2<br/>Feedback: _v4_concept_validation</small>"]
    end

    subgraph SceneRetry["Phase 1b: Scene Retry (selective Send)"]
        direction LR
        SR1["scene_designer ×N"] --> SR2["scene_design_merge"]
        SR2 -->|"failed_scene_ids"| SR3{{"retry_router"}}
        SR3 -->|"Send only failed"| SR1
        SR3 -->|"all passed"| SR4["graph_builder"]
        SR5["<small>Scope: 1 scene, ~4K tokens<br/>Max retries: 2 per scene<br/>Feedback: _v4_scene_design_validation[sid]</small>"]
    end

    subgraph ContentRetry["Phase 2a: Content Retry (selective Send)"]
        direction LR
        CRT1["content_generator ×M"] --> CRT2["content_merge"]
        CRT2 -->|"failed_mechanic_ids"| CRT3{{"retry_router"}}
        CRT3 -->|"Send only failed"| CRT1
        CRT3 -->|"all passed"| CRT4["interaction_designers"]
        CRT5["<small>Scope: 1 mechanic, ~3K tokens<br/>Max retries: 2 per mechanic<br/>Feedback: _v4_content_validation[mid]</small>"]
    end

    subgraph InteractionRetry["Phase 2b: Interaction Retry (selective Send)"]
        direction LR
        IRT1["interaction_designer ×N"] --> IRT2["interaction_merge"]
        IRT2 -->|"failed_interaction_scene_ids"| IRT3{{"retry_router"}}
        IRT3 -->|"Send only failed"| IRT1
        IRT3 -->|"all passed"| IRT4["asset_needs_analyzer"]
        IRT5["<small>Scope: 1 scene, ~3K tokens<br/>Max retries: 1 per scene<br/>Feedback: _v4_interaction_validation[sid]</small>"]
    end

    subgraph ArtRetry["Phase 3a: Art Direction Retry (selective Send)"]
        direction LR
        ART1["art_director ×N"] --> ART2["art_direction_merge"]
        ART2 -->|"failed_art_direction_scene_ids"| ART3{{"retry_router"}}
        ART3 -->|"Send only failed"| ART1
        ART3 -->|"all passed"| ART4["asset_chain_dispatch"]
        ART5["<small>Scope: 1 scene, ~5K tokens<br/>Max retries: 1 per scene<br/>Feedback: _v4_art_direction_validation[sid]</small>"]
    end

    style ConceptRetry fill:#1b2838,stroke:#30363d
    style SceneRetry fill:#1b2838,stroke:#30363d
    style ContentRetry fill:#1b2838,stroke:#30363d
    style InteractionRetry fill:#1b2838,stroke:#30363d
    style ArtRetry fill:#1b2838,stroke:#30363d
    </pre>
  </div>

  <h3>Retry Cost Comparison</h3>
  <table>
    <tr><th>Pipeline</th><th>Retry Scope</th><th>Tokens per Retry</th><th>What Gets Re-run</th></tr>
    <tr><td>V3 (ReAct)</td><td>Entire agent</td><td>~15K</td><td>Full ReAct conversation + all tools</td></tr>
    <tr><td>V4 concept</td><td>1 concept call</td><td>~4K</td><td>game_concept_designer only</td></tr>
    <tr><td>V4 scene</td><td>1 scene</td><td>~4K</td><td>1 scene_designer only (others untouched)</td></tr>
    <tr><td>V4 content</td><td>1 mechanic</td><td>~3K</td><td>1 content_generator only</td></tr>
    <tr><td>V4 interaction</td><td>1 scene</td><td>~3K</td><td>1 interaction_designer only</td></tr>
    <tr><td>V4 art direction</td><td>1 scene</td><td>~5K</td><td>1 asset_art_director only</td></tr>
  </table>
</div>

<!-- ═══════════════════════════════════════════════════ -->
<!-- MECHANIC SUBGRAPHS -->
<!-- ═══════════════════════════════════════════════════ -->

<div class="section" id="tab-dragdrop">
  <h2>Drag &amp; Drop — Mechanic Subgraph</h2>
  <div class="diagram-container">
    <pre class="mermaid">
graph TB
    subgraph Concept["Phase 1a: Concept"]
        MC1["MechanicChoice<br/><small>type: drag_drop<br/>zone_labels_used: [left_atrium, ...]<br/>expected_item_count: 6<br/>points_per_item: 10</small>"]
    end
    subgraph Design["Phase 1b: Scene Design"]
        MCD["MechanicCreativeDesign<br/><small>visual_style: clean_labels_with_pins<br/>card_type: text_with_description<br/>instruction_text: Drag each label...<br/>hint_strategy: progressive<br/>feedback_style: encouraging</small>"]
    end
    subgraph Content["Phase 2a: Content Generator"]
        DDC["DragDropContent<br/><small>labels: [{text, zone_label}]<br/>distractor_labels: []<br/>interaction_mode: drag_drop<br/>feedback_timing: immediate<br/>label_style: text_with_description<br/>leader_line_style: elbow<br/>tray_position: bottom<br/>placement_animation: spring<br/>zone_idle_animation: pulse<br/>max_attempts: null<br/>shuffle_labels: true</small>"]
    end
    subgraph Scoring["Phase 2b: Interaction Designer"]
        MS["MechanicScoring<br/><small>strategy: per_item<br/>points_per_correct: 10<br/>max_score: 60<br/>partial_credit: true</small>"]
        MF["MechanicFeedback<br/><small>on_correct: Correct! The left atrium...<br/>on_incorrect: Not quite...<br/>misconception_feedback: [...]</small>"]
    end
    subgraph Assets["Phase 3: Assets"]
        DIA["DiagramAssetResult<br/><small>image_url: /assets/heart.png<br/>zones: [DetectedZone × 6]</small>"]
    end
    subgraph Blueprint["Phase 4: Blueprint Output"]
        BP1["dragDropConfig: {<br/>&nbsp;&nbsp;interactionMode: drag_drop<br/>&nbsp;&nbsp;feedbackTiming: immediate<br/>&nbsp;&nbsp;labelStyle: text_with_description<br/>&nbsp;&nbsp;leaderLineStyle: elbow<br/>&nbsp;&nbsp;trayPosition: bottom<br/>&nbsp;&nbsp;placementAnimation: spring<br/>&nbsp;&nbsp;zoneIdleAnimation: pulse<br/>&nbsp;&nbsp;shuffleLabels: true<br/>}"]
        BP2["labels: [{id, text, correctZoneId}]"]
        BP3["zones: [{id, label, points, center}]"]
    end

    MC1 --> MCD --> DDC
    DDC --> MS & MF
    DDC --> BP1
    DIA --> BP3
    DDC --> BP2
    MS --> BP1

    style Concept fill:#1b2838,stroke:#30363d
    style Design fill:#1f1b2e,stroke:#bc8cff
    style Content fill:#2d1b4e,stroke:#bc8cff
    style Scoring fill:#1f1b2e,stroke:#bc8cff
    style Assets fill:#3d2e1b,stroke:#d29922
    style Blueprint fill:#1b3d2e,stroke:#3fb950
    </pre>
  </div>
  <h4>Frontend Config Fields: 16 populated / 29 total</h4>
  <p>Remaining 13 fields use frontend defaults (zoom, minimap, spring physics, distractor rejection mode). These are UI-level preferences that don't need LLM generation.</p>
</div>

<div class="section" id="tab-clickid">
  <h2>Click to Identify — Mechanic Subgraph</h2>
  <div class="diagram-container">
    <pre class="mermaid">
graph TB
    subgraph Concept["Phase 1a"]
        MC1["MechanicChoice<br/><small>type: click_to_identify<br/>zone_labels_used: [mitochondria, ...]<br/>expected_item_count: 8</small>"]
    end
    subgraph Design["Phase 1b"]
        MCD["MechanicCreativeDesign<br/><small>visual_style: subtle_highlight<br/>prompt_style: functional<br/>instruction_text: Click each organelle...</small>"]
    end
    subgraph Content["Phase 2a"]
        CIC["ClickToIdentifyContent<br/><small>prompts: [ClickPrompt × 8]<br/>prompt_style: functional<br/>selection_mode: sequential<br/>highlight_style: outlined<br/>magnification_enabled: true<br/>explore_mode_enabled: false<br/>show_zone_count: true</small>"]
    end
    subgraph Scoring["Phase 2b"]
        MS["MechanicScoring<br/><small>max_score: 80</small>"]
        MF["MechanicFeedback"]
        ZS["ZoneSpec[] with LLM hints"]
    end
    subgraph Blueprint["Phase 4"]
        BP["clickToIdentifyConfig: {<br/>&nbsp;&nbsp;promptStyle: functional<br/>&nbsp;&nbsp;selectionMode: sequential<br/>&nbsp;&nbsp;highlightStyle: outlined<br/>&nbsp;&nbsp;magnificationEnabled: true<br/>&nbsp;&nbsp;showZoneCount: true<br/>}"]
    end

    MC1 --> MCD --> CIC --> MS & MF & ZS --> BP

    style Concept fill:#1b2838,stroke:#30363d
    style Design fill:#1f1b2e,stroke:#bc8cff
    style Content fill:#2d1b4e,stroke:#bc8cff
    style Scoring fill:#1f1b2e,stroke:#bc8cff
    style Blueprint fill:#1b3d2e,stroke:#3fb950
    </pre>
  </div>
</div>

<div class="section" id="tab-tracepath">
  <h2>Trace Path — Mechanic Subgraph</h2>
  <div class="diagram-container">
    <pre class="mermaid">
graph TB
    subgraph Concept["Phase 1a"]
        MC1["MechanicChoice<br/><small>type: trace_path<br/>zone_labels_used: [start, lungs, heart, ...]<br/>expected_item_count: 3 paths</small>"]
    end
    subgraph Design["Phase 1b"]
        MCD["MechanicCreativeDesign<br/><small>visual_style: flowing_blood<br/>path_process: blood_circulation<br/>instruction_text: Trace the path of blood...</small>"]
    end
    subgraph Content["Phase 2a"]
        TPC["TracePathContent<br/><small>paths: [TracePath × 3]<br/>  each with waypoints[TraceWaypoint]<br/>path_type: linear<br/>drawing_mode: click_waypoints<br/>particle_theme: droplets<br/>particle_speed: medium<br/>show_direction_arrows: true<br/>show_waypoint_labels: true<br/>submit_mode: immediate</small>"]
    end
    subgraph Blueprint["Phase 4"]
        BP["tracePathConfig: {<br/>&nbsp;&nbsp;pathType: linear<br/>&nbsp;&nbsp;drawingMode: click_waypoints<br/>&nbsp;&nbsp;particleTheme: droplets<br/>&nbsp;&nbsp;particleSpeed: medium<br/>&nbsp;&nbsp;showDirectionArrows: true<br/>&nbsp;&nbsp;showWaypointLabels: true<br/>}"]
    end

    MC1 --> MCD --> TPC --> BP

    style Concept fill:#1b2838,stroke:#30363d
    style Design fill:#1f1b2e,stroke:#bc8cff
    style Content fill:#2d1b4e,stroke:#bc8cff
    style Blueprint fill:#1b3d2e,stroke:#3fb950
    </pre>
  </div>
</div>

<div class="section" id="tab-sequencing">
  <h2>Sequencing — Mechanic Subgraph</h2>
  <div class="diagram-container">
    <pre class="mermaid">
graph TB
    subgraph Concept["Phase 1a"]
        MC1["MechanicChoice<br/><small>type: sequencing<br/>sequence_topic: cell_division<br/>expected_item_count: 6</small>"]
    end
    subgraph Design["Phase 1b"]
        MCD["MechanicCreativeDesign<br/><small>layout_mode: horizontal_timeline<br/>card_type: text_with_icon<br/>connector_style: arrow<br/>instruction_text: Arrange the stages...</small>"]
    end
    subgraph Content["Phase 2a"]
        SC["SequencingContent<br/><small>items: [SequenceItem × 6]<br/>  each: {id, text, description, icon,<br/>         order_index, is_distractor}<br/>correct_order: [id1, id2, ...]<br/>sequence_type: linear<br/>layout_mode: horizontal_timeline<br/>interaction_pattern: drag_reorder<br/>card_type: text_with_icon<br/>connector_style: arrow<br/>show_position_numbers: true<br/>allow_partial_credit: true</small>"]
    end
    subgraph ItemImages["Phase 3: Item Images"]
        II["Item images (if image_description set)<br/><small>SequenceItem.image_description →<br/>ArtDirectedItemImage →<br/>ItemImageResult.image_url</small>"]
    end
    subgraph Blueprint["Phase 4"]
        BP["sequenceConfig: {<br/>&nbsp;&nbsp;sequenceType: linear<br/>&nbsp;&nbsp;items: [{id, text, description, icon, image}]<br/>&nbsp;&nbsp;correctOrder: [...]<br/>&nbsp;&nbsp;layoutMode: horizontal_timeline<br/>&nbsp;&nbsp;interactionPattern: drag_reorder<br/>&nbsp;&nbsp;cardType: text_with_icon<br/>&nbsp;&nbsp;connectorStyle: arrow<br/>&nbsp;&nbsp;showPositionNumbers: true<br/>&nbsp;&nbsp;allowPartialCredit: true<br/>}"]
    end

    MC1 --> MCD --> SC
    SC --> II --> BP
    SC --> BP

    style Concept fill:#1b2838,stroke:#30363d
    style Design fill:#1f1b2e,stroke:#bc8cff
    style Content fill:#2d1b4e,stroke:#bc8cff
    style ItemImages fill:#3d2e1b,stroke:#d29922
    style Blueprint fill:#1b3d2e,stroke:#3fb950
    </pre>
  </div>
</div>

<div class="section" id="tab-sorting">
  <h2>Sorting Categories — Mechanic Subgraph</h2>
  <div class="diagram-container">
    <pre class="mermaid">
graph TB
    subgraph Concept["Phase 1a"]
        MC1["MechanicChoice<br/><small>type: sorting_categories<br/>category_names: [Plant, Animal]<br/>expected_item_count: 8</small>"]
    end
    subgraph Design["Phase 1b"]
        MCD["MechanicCreativeDesign<br/><small>layout_mode: bucket<br/>card_type: text_with_icon<br/>instruction_text: Sort each cell type...</small>"]
    end
    subgraph Content["Phase 2a"]
        SC["SortingContent<br/><small>categories: [SortingCategory × 2]<br/>  each: {id, label, description, color}<br/>items: [SortingItem × 8]<br/>  each: {id, text, correct_category_id,<br/>         difficulty, image_description}<br/>sort_mode: bucket<br/>item_card_type: text_with_icon<br/>container_style: labeled_bin<br/>submit_mode: immediate_feedback<br/>allow_multi_category: false<br/>show_category_hints: true</small>"]
    end
    subgraph Palette["Phase 3: Color Palette"]
        CP["ArtDirectedColorPalette<br/><small>Plant → #4CAF50<br/>Animal → #FF5722</small>"]
    end
    subgraph Blueprint["Phase 4"]
        BP["sortingConfig: {<br/>&nbsp;&nbsp;categories: [{id, label, color}]<br/>&nbsp;&nbsp;items: [{id, text, correctCategoryId}]<br/>&nbsp;&nbsp;sortMode: bucket<br/>&nbsp;&nbsp;containerStyle: labeled_bin<br/>&nbsp;&nbsp;submitMode: immediate_feedback<br/>}"]
    end

    MC1 --> MCD --> SC
    SC --> CP --> BP
    SC --> BP

    style Concept fill:#1b2838,stroke:#30363d
    style Design fill:#1f1b2e,stroke:#bc8cff
    style Content fill:#2d1b4e,stroke:#bc8cff
    style Palette fill:#3d2e1b,stroke:#d29922
    style Blueprint fill:#1b3d2e,stroke:#3fb950
    </pre>
  </div>
</div>

<div class="section" id="tab-memory">
  <h2>Memory Match — Mechanic Subgraph</h2>
  <div class="diagram-container">
    <pre class="mermaid">
graph TB
    subgraph Concept["Phase 1a"]
        MC1["MechanicChoice<br/><small>type: memory_match<br/>match_type: term_to_definition<br/>expected_item_count: 6 pairs</small>"]
    end
    subgraph Design["Phase 1b"]
        MCD["MechanicCreativeDesign<br/><small>layout_mode: grid<br/>card_type: text_only<br/>instruction_text: Match each term...</small>"]
    end
    subgraph Content["Phase 2a"]
        MMC["MemoryMatchContent<br/><small>pairs: [MemoryPair × 6]<br/>  each: {id, front, back,<br/>         front_type, back_type,<br/>         explanation, category}<br/>match_type: term_to_definition<br/>game_variant: classic<br/>grid_size: [3, 4]<br/>card_back_style: question_mark<br/>matched_card_behavior: fade<br/>show_explanation_on_match: true<br/>flip_duration_ms: 400</small>"]
    end
    subgraph Blueprint["Phase 4"]
        BP["memoryMatchConfig: {<br/>&nbsp;&nbsp;pairs: [{id, front, back, explanation}]<br/>&nbsp;&nbsp;matchType: term_to_definition<br/>&nbsp;&nbsp;gameVariant: classic<br/>&nbsp;&nbsp;gridSize: [3, 4]<br/>&nbsp;&nbsp;cardBackStyle: question_mark<br/>&nbsp;&nbsp;matchedCardBehavior: fade<br/>&nbsp;&nbsp;showExplanationOnMatch: true<br/>}"]
    end

    MC1 --> MCD --> MMC --> BP

    style Concept fill:#1b2838,stroke:#30363d
    style Design fill:#1f1b2e,stroke:#bc8cff
    style Content fill:#2d1b4e,stroke:#bc8cff
    style Blueprint fill:#1b3d2e,stroke:#3fb950
    </pre>
  </div>
</div>

<div class="section" id="tab-branching">
  <h2>Branching Scenario — Mechanic Subgraph</h2>
  <p><span class="tag tag-llm">Most complex mechanic</span> — Decision graph construction. ReAct candidate for V4.1.</p>
  <div class="diagram-container">
    <pre class="mermaid">
graph TB
    subgraph Concept["Phase 1a"]
        MC1["MechanicChoice<br/><small>type: branching_scenario<br/>narrative_premise: patient diagnosis<br/>expected_item_count: 8 nodes</small>"]
    end
    subgraph Design["Phase 1b"]
        MCD["MechanicCreativeDesign<br/><small>layout_mode: tree<br/>narrative_hook: You are a doctor...<br/>instruction_text: Make clinical decisions...</small>"]
    end
    subgraph Content["Phase 2a: content_generator (gemini-pro)"]
        BC["BranchingContent<br/><small>nodes: [DecisionNode × 8]<br/>  each: {id, question, description,<br/>    node_type, options: [DecisionOption],<br/>    narrative_text, ending_type}<br/>start_node_id: n1<br/>narrative_structure: branching<br/>show_path_taken: true<br/>allow_backtrack: false<br/>show_consequences: true</small>"]
    end
    subgraph Validate["Phase 2a: content_validator"]
        VAL["Checks:<br/><small>• Graph connectivity from start_node<br/>• All end nodes reachable<br/>• At least 1 good ending<br/>• No orphan nodes<br/>• Options have valid next_node_ids</small>"]
    end
    subgraph Blueprint["Phase 4"]
        BP["branchingConfig: {<br/>&nbsp;&nbsp;nodes: [{id, question, options, ...}]<br/>&nbsp;&nbsp;startNodeId: n1<br/>&nbsp;&nbsp;narrativeStructure: branching<br/>&nbsp;&nbsp;showPathTaken: true<br/>&nbsp;&nbsp;allowBacktrack: false<br/>&nbsp;&nbsp;showConsequences: true<br/>}"]
    end

    MC1 --> MCD --> BC --> VAL --> BP
    VAL -.->|"graph disconnected"| BC

    style Concept fill:#1b2838,stroke:#30363d
    style Design fill:#1f1b2e,stroke:#bc8cff
    style Content fill:#2d1b4e,stroke:#bc8cff
    style Validate fill:#3d1b1b,stroke:#f85149
    style Blueprint fill:#1b3d2e,stroke:#3fb950
    </pre>
  </div>
  <div class="info-card warn">
    <h4>Why Branching is a ReAct Candidate</h4>
    <p>Decision graph construction requires ensuring connectivity, reachability, and narrative coherence simultaneously. A single-call may produce disconnected graphs that need retries. ReAct with tools like <code>create_node()</code>, <code>add_connection()</code>, <code>validate_graph()</code> could build iteratively. However, the content_validator + retry loop achieves the same result with simpler implementation. Try single-call first.</p>
  </div>
</div>

<div class="section" id="tab-compare">
  <h2>Compare &amp; Contrast — Mechanic Subgraph</h2>
  <p><span class="tag tag-tool">Requires 2 diagrams</span> — Most asset-heavy mechanic.</p>
  <div class="diagram-container">
    <pre class="mermaid">
graph TB
    subgraph Concept["Phase 1a"]
        MC1["MechanicChoice<br/><small>type: compare_contrast<br/>comparison_subjects: [Plant Cell, Animal Cell]<br/>zone_labels_used: [...]</small>"]
    end
    subgraph Design["Phase 1b"]
        MCD["MechanicCreativeDesign<br/><small>layout_mode: side_by_side<br/>instruction_text: Compare structures...</small>"]
        SCD["SceneCreativeDesign<br/><small>image_spec: Plant cell diagram<br/>second_image_spec: Animal cell diagram</small>"]
    end
    subgraph Content["Phase 2a"]
        CCC["CompareContrastContent<br/><small>subject_a: {id, name: Plant Cell,<br/>  zone_labels: [...], image_spec: ref}<br/>subject_b: {id, name: Animal Cell,<br/>  zone_labels: [...], image_spec: ref}<br/>expected_categories: {<br/>  cell_wall: unique_a,<br/>  mitochondria: similar, ...}<br/>comparison_mode: side_by_side<br/>highlight_matching: true<br/>category_colors: {similar: #4CAF50, ...}</small>"]
    end
    subgraph Assets["Phase 3: Two Diagrams"]
        D1["DiagramAssetResult A<br/><small>image_url: /assets/plant_cell.png<br/>zones: [DetectedZone × 8]</small>"]
        D2["DiagramAssetResult B<br/><small>image_url: /assets/animal_cell.png<br/>zones: [DetectedZone × 7]</small>"]
    end
    subgraph Blueprint["Phase 4"]
        BP["compareConfig: {<br/>&nbsp;&nbsp;diagramA: {id, name, imageUrl, zones: [...]}<br/>&nbsp;&nbsp;diagramB: {id, name, imageUrl, zones: [...]}<br/>&nbsp;&nbsp;expectedCategories: {...}<br/>&nbsp;&nbsp;comparisonMode: side_by_side<br/>&nbsp;&nbsp;highlightMatching: true<br/>&nbsp;&nbsp;categoryColors: {...}<br/>}"]
    end

    MC1 --> MCD & SCD
    MCD --> CCC
    SCD --> Assets
    CCC --> BP
    D1 --> BP
    D2 --> BP

    style Concept fill:#1b2838,stroke:#30363d
    style Design fill:#1f1b2e,stroke:#bc8cff
    style Content fill:#2d1b4e,stroke:#bc8cff
    style Assets fill:#3d2e1b,stroke:#d29922
    style Blueprint fill:#1b3d2e,stroke:#3fb950
    </pre>
  </div>
</div>

<div class="section" id="tab-description">
  <h2>Description Matching — Mechanic Subgraph</h2>
  <div class="diagram-container">
    <pre class="mermaid">
graph TB
    subgraph Concept["Phase 1a"]
        MC1["MechanicChoice<br/><small>type: description_matching<br/>description_source: dk_definitions<br/>zone_labels_used: [...]</small>"]
    end
    subgraph Design["Phase 1b"]
        MCD["MechanicCreativeDesign<br/><small>layout_mode: spatial<br/>instruction_text: Match each description...</small>"]
    end
    subgraph Content["Phase 2a"]
        DMC["DescriptionMatchingContent<br/><small>descriptions: [DescriptionEntry × 6]<br/>  each: {zone_label, description}<br/>mode: multiple_choice<br/>distractor_descriptions: [str × 2]<br/>show_connecting_lines: true<br/>defer_evaluation: false<br/>description_panel_position: right</small>"]
    end
    subgraph Transform["Blueprint Assembler Transform"]
        TR["List[DescriptionEntry] →<br/>Dict[zone_id, description]<br/><small>zone_label → zone_id via asset mapping</small>"]
    end
    subgraph Blueprint["Phase 4"]
        BP["descriptionMatchingConfig: {<br/>&nbsp;&nbsp;descriptions: {zone_1_3: '...', ...}<br/>&nbsp;&nbsp;mode: multiple_choice<br/>&nbsp;&nbsp;showConnectingLines: true<br/>&nbsp;&nbsp;deferEvaluation: false<br/>&nbsp;&nbsp;descriptionPanelPosition: right<br/>}"]
    end

    MC1 --> MCD --> DMC --> TR --> BP

    style Concept fill:#1b2838,stroke:#30363d
    style Design fill:#1f1b2e,stroke:#bc8cff
    style Content fill:#2d1b4e,stroke:#bc8cff
    style Transform fill:#1b3d2e,stroke:#3fb950
    style Blueprint fill:#1b3d2e,stroke:#3fb950
    </pre>
  </div>
  <div class="info-card neutral">
    <h4>Type Conversion</h4>
    <p>Backend produces <code>List[DescriptionEntry]</code> (LLM-friendly). Blueprint assembler converts to <code>Record&lt;string, string&gt;</code> (frontend-friendly) during zone_label → zone_id mapping.</p>
  </div>
</div>

<div class="section" id="tab-hierarchical">
  <h2>Hierarchical — Mechanic Subgraph</h2>
  <div class="diagram-container">
    <pre class="mermaid">
graph TB
    subgraph Concept["Phase 1a"]
        MC1["MechanicChoice<br/><small>type: hierarchical<br/>zone_labels_used: [heart, left_atrium, ...]<br/>children: [MechanicChoice(drag_drop)]</small>"]
    end
    subgraph Design["Phase 1b"]
        MCD["MechanicCreativeDesign<br/><small>layout_mode: nested<br/>instruction_text: Explore the heart...</small>"]
    end
    subgraph Content["Phase 2a"]
        HC["HierarchicalContent<br/><small>groups: [HierarchicalGroup × 2]<br/>  each: {id, parent_label, child_labels,<br/>         reveal_trigger: complete_parent}</small>"]
        DDC["DragDropContent (child mechanic)<br/><small>labels for child zones</small>"]
    end
    subgraph Blueprint["Phase 4"]
        BP1["zoneGroups: [{<br/>&nbsp;&nbsp;id: zg_1_0,<br/>&nbsp;&nbsp;parentZoneId: zone_1_0,<br/>&nbsp;&nbsp;childZoneIds: [zone_1_1, zone_1_2],<br/>&nbsp;&nbsp;revealTrigger: complete_parent<br/>}]"]
        BP2["Parent zones initially visible<br/>Child zones hidden until parent complete"]
    end

    MC1 --> MCD --> HC & DDC --> BP1 & BP2

    style Concept fill:#1b2838,stroke:#30363d
    style Design fill:#1f1b2e,stroke:#bc8cff
    style Content fill:#2d1b4e,stroke:#bc8cff
    style Blueprint fill:#1b3d2e,stroke:#3fb950
    </pre>
  </div>
  <div class="info-card neutral">
    <h4>Hierarchical is a Meta-Mechanic</h4>
    <p>It wraps other mechanics (typically drag_drop or click_to_identify) with parent/child zone relationships. The child mechanic's MechanicChoice is nested inside the parent's <code>children</code> array. Graph builder creates separate MechanicPlan entries linked by <code>parent_mechanic_id</code>.</p>
  </div>
</div>

<!-- ═══════════════════════════════════════════════════ -->
<!-- TAB: Blueprint Assembly -->
<!-- ═══════════════════════════════════════════════════ -->
<div class="section" id="tab-assembly">
  <h2>Blueprint Assembly — Final Transform</h2>
  <p>How GamePlan + SceneContent + SceneAssets merge into the frontend-ready blueprint JSON.</p>

  <div class="diagram-container">
    <pre class="mermaid">
graph TB
    subgraph Inputs["Assembly Inputs"]
        GP["GamePlan<br/><small>title, narrative,<br/>scenes[].mechanics[]</small>"]
        SC["SceneContent<br/><small>zone_specs, mechanic_contents,<br/>scoring[], feedback[],<br/>mode_transitions[]</small>"]
        SA["SceneAssets<br/><small>primary_diagram.image_url,<br/>primary_diagram.zones[],<br/>item_images[],<br/>color_palettes[]</small>"]
    end

    subgraph ZoneMapping["Step 1: Zone Mapping"]
        ZM1["For each DetectedZone in SceneAssets:"]
        ZM2["zone_id = zone_{scene}_{index}"]
        ZM3["label_to_zone_id = {label: zone_id}"]
        ZM4["Convert coordinates → points/center"]
    end

    subgraph LabelMapping["Step 2: Label Building"]
        LM1["For drag_drop: DragDropContent.labels →<br/>Label objects with correctZoneId"]
        LM2["For other mechanics: zone_specs →<br/>Label objects for visible zones"]
    end

    subgraph ConfigMerge["Step 3: Config Merge (per mechanic)"]
        CM1["Copy MechanicContent fields"]
        CM2["Add visual config (already in content)"]
        CM3["Inject image URLs from SceneAssets"]
        CM4["Convert zone_labels → zone_ids"]
        CM5["camelCase all keys"]
    end

    subgraph ScoringMerge["Step 4: Scoring/Feedback"]
        SM1["Match scoring[] by mechanic_id"]
        SM2["Match feedback[] by mechanic_id"]
        SM3["Build mechanics[] array"]
        SM4["Build modeTransitions[]"]
    end

    subgraph Output["Blueprint JSON"]
        O1["templateType: INTERACTIVE_DIAGRAM"]
        O2["title, narrativeIntro"]
        O3["diagram: {assetUrl, zones[], ...}"]
        O4["labels: [{id, text, correctZoneId}]"]
        O5["mechanics: [{type, config, scoring, feedback}]"]
        O6["sequenceConfig / sortingConfig / etc."]
        O7["scoringStrategy, hints, feedbackMessages"]
        O8["animationCues (defaults)"]
    end

    GP --> ZoneMapping
    SA --> ZoneMapping
    ZoneMapping --> LabelMapping
    SC --> LabelMapping
    SC --> ConfigMerge
    SA --> ConfigMerge
    ZoneMapping --> ConfigMerge
    ConfigMerge --> ScoringMerge
    SC --> ScoringMerge
    GP --> ScoringMerge
    ScoringMerge --> Output

    style Inputs fill:#1b2838,stroke:#30363d
    style ZoneMapping fill:#1b3d2e,stroke:#3fb950
    style LabelMapping fill:#1b3d2e,stroke:#3fb950
    style ConfigMerge fill:#1b3d2e,stroke:#3fb950
    style ScoringMerge fill:#1b3d2e,stroke:#3fb950
    style Output fill:#0d2818,stroke:#3fb950,stroke-width:2px
    </pre>
  </div>

  <h3>Per-Mechanic Config Key Mapping</h3>
  <table>
    <tr><th>Mechanic</th><th>Blueprint Key</th><th>Source Content</th><th>Special Transforms</th></tr>
    <tr><td>drag_drop</td><td><code>dragDropConfig</code></td><td>DragDropContent</td><td>labels → Label objects with correctZoneId</td></tr>
    <tr><td>click_to_identify</td><td><code>clickToIdentifyConfig</code></td><td>ClickToIdentifyContent</td><td>prompts.zone_label → zone_id</td></tr>
    <tr><td>trace_path</td><td><code>tracePathConfig</code></td><td>TracePathContent</td><td>waypoints.zone_label → zone_id</td></tr>
    <tr><td>sequencing</td><td><code>sequenceConfig</code></td><td>SequencingContent</td><td>items.image_description → image URL from SceneAssets</td></tr>
    <tr><td>sorting_categories</td><td><code>sortingConfig</code></td><td>SortingContent</td><td>category.color from ColorPaletteResult</td></tr>
    <tr><td>memory_match</td><td><code>memoryMatchConfig</code></td><td>MemoryMatchContent</td><td>Direct mapping (no zone refs)</td></tr>
    <tr><td>branching_scenario</td><td><code>branchingConfig</code></td><td>BranchingContent</td><td>node.image_description → image URL</td></tr>
    <tr><td>compare_contrast</td><td><code>compareConfig</code></td><td>CompareContrastContent</td><td>Inject diagramA/B imageUrl + zones from SceneAssets</td></tr>
    <tr><td>description_matching</td><td><code>descriptionMatchingConfig</code></td><td>DescriptionMatchingContent</td><td>List[DescriptionEntry] → Dict[zone_id, description]</td></tr>
    <tr><td>hierarchical</td><td><code>zoneGroups</code></td><td>HierarchicalContent</td><td>parent_label/child_labels → zone_ids, generate group IDs</td></tr>
  </table>
</div>

<script>
  // Tab switching
  document.querySelectorAll('.nav button').forEach(btn => {
    btn.addEventListener('click', () => {
      document.querySelectorAll('.nav button').forEach(b => b.classList.remove('active'));
      document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
      btn.classList.add('active');
      document.getElementById('tab-' + btn.dataset.tab).classList.add('active');
    });
  });

  // Initialize Mermaid
  mermaid.initialize({
    startOnLoad: true,
    theme: 'dark',
    themeVariables: {
      primaryColor: '#2d1b4e',
      primaryTextColor: '#e6edf3',
      primaryBorderColor: '#bc8cff',
      lineColor: '#8b949e',
      secondaryColor: '#1b3d2e',
      tertiaryColor: '#1b2838',
      fontFamily: '-apple-system, BlinkMacSystemFont, Segoe UI, Helvetica, Arial',
      fontSize: '13px',
    },
    flowchart: {
      htmlLabels: true,
      curve: 'basis',
      padding: 15,
      nodeSpacing: 30,
      rankSpacing: 50,
    },
  });
</script>

</body>
</html>
